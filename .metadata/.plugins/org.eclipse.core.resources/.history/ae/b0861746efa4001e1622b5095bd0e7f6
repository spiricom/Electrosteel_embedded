/*
 * string1.c
 *
 *  Created on: Dec 27, 2023
 *      Author: jeffsnyder
 */
#include "main.h"
#include "leaf.h"
#include "codec.h"
#include "i2c.h"
#include "gpio.h"
#include "spi.h"
#include "parameters.h"
#include "audiostream.h"
#include "arm_math.h"
#include "string1.h"


tSimpleLivingString3 livStr[NUM_STRINGS_PER_BOARD];


float FORCE_INLINE pickupNonLinearity(float x)
{
	x = x * 2.0f; //initial scaling to match mm of displacement
	float out = (0.075f * x) + (0.00675f * x * x) +( 0.00211f * x * x * x) + (0.000475f * x * x * x * x) + (0.000831f * x * x * x * x *x);
	return out * 4.366812227074236f; //output scaling to bring +/-0.229 to +/-1.0
}


void __ATTR_ITCMRAM audioInitString1()
{
	for (int v = 0; v < numStringsThisBoard; v++)
	{

		for (int v = 0; v < numStringsThisBoard; v++)
		{

			tSimpleLivingString3_initToPool(&livStr[v], 4, 220.0f, 17000.0f,
														 0.99999f, 0.0f, 0.01f,
													 0.01f, 0, &mediumPool);
			tSimpleLivingString3_setTargetLev(&livStr[v], 0.047059f);
			tSimpleLivingString3_setLevSmoothFactor(&livStr[v], 0.0301913f);
			tSimpleLivingString3_setLevStrength(&livStr[v], 0.0f);
			tSimpleLivingString3_setLevMode(&livStr[v], 1);

		}
		//load string1 default params:
		for (int i = 0; i < 12; i++)
		{
			tExpSmooth_setValAndDest(&knobSmoothers[i], string1Defaults[i]);
			knobFrozen[i] = 1;
		}
		tVZFilter_setFreq(&noiseFilt2, 3332.0f); //based on testing with knob values
		whichStringModelLoaded = String1Loaded;
		audioFrameFunction = audioFrameString1;
	}
}


void __ATTR_ITCMRAM audioFreeString1()
{
	for (int v = 0; v < numStringsThisBoard; v++)
	{
		tSimpleLivingString3_free(&livStr[v]);
	}
}

void __ATTR_ITCMRAM audioFrameString1(uint16_t buffer_offset)
{
	//HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;

	if (resetStringInputs)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			//note off
			lsDecay[i] = 0;
			previousStringInputs[i] = 0;
		}
		resetStringInputs = 0;
	}
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;
				stringOctave[i] = octave;
				//then it's the string synth
				//tSimpleLivingString3_setDecay(&livStr[i], 20.0f);
				tSimpleLivingString3_pluck(&livStr[i], amplitz, LEAF_clip(0.0f, ((pluckPos * randomFactors[currentRandom]) * knobScaled[2]) + (pluckPos * (1.0f - knobScaled[2])),1.0f));
				currentRandom++;
				lsDecay[i] = 1;

			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				//tSimpleLivingString3_setDecay(&livStr[i], 0.1f);
				lsDecay[i] = 0;
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}
	//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		int iplusbuffer = buffer_offset + i;
		current_sample = (int32_t)(audioTickString1() * TWO_TO_23);
		audioOutBuffer[iplusbuffer] = current_sample;
		audioOutBuffer[iplusbuffer + 1] = current_sample;
	}

	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;
	//HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;

}



float __ATTR_ITCMRAM audioTickString1(void)
{
	float temp = 0.0f;
	float note[numStringsThisBoard];

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}
	pluckPos = knobScaled[9];

	for (int i = 0; i < numStringsThisBoard; i++)
	{
		note[i] = stringMIDIPitches[i] + stringOctave[i];
		//sourceValues[MIDI_KEY_SOURCE_OFFSET][v] = (note[v] - midiKeySubtractor) * midiKeyDivisor;

		if (note[i] < 0.0f)
		{
			note[i] = 0.0f;
		}
		if (note[i] > 127.0f)
		{
			note[i] = 127.0f;
		}
		if (isnan(note[i]))
		{
			note[i] = 64.0f;
		}

		//float finalFreq = mtof(note[i]);
		float dampFreq = 15778.3f;
		float decay = 0.1f;
		if (lsDecay[i])
		{
			decay = (knobScaled[10] * 800.0f) + 10.0f;
		}
		tSimpleLivingString3_setPickupPoint(&livStr[i], knobScaled[8]);
		tSimpleLivingString3_setDecay(&livStr[i], decay);
		tSimpleLivingString3_setDampFreq(&livStr[i], dampFreq);
		tSimpleLivingString3_setLevStrength(&livStr[i], knobScaled[0] * 0.0352872f);

		livStr[i]->rippleGain = knobScaled[5] * -0.03f;
		livStr[i]->rippleDelay = knobScaled[11];
		tExpSmooth_setDest(&pitchSmoother[0][i], mtof(note[i]));
		float finalFreq = tExpSmooth_tick(&pitchSmoother[0][i]);
		tSimpleLivingString3_setFreq(&livStr[i], finalFreq);
		float barDelta = fabsf(barInMIDI[0]-prevBarInMIDI[0]);
		//if (barDelta > 0.2f)
		{
			//barDelta = 0.0f; //to avoid noise on open string glitches
		}
		tExpSmooth_setDest(&barSlideSmoother[i], barDelta);
		barDelta = tExpSmooth_tick(&barSlideSmoother[i]);
		barDelta = tEnvelopeFollower_tick(&barNoiseSmoother[i], barDelta);
		prevBarInMIDI[0] = barInMIDI[0];
		//tVZFilter_setFreq(&noiseFilt, faster_mtof(knobScaled[5] * 128.0f));

		float filtNoise = tVZFilter_tickEfficient(&noiseFilt2, tNoise_tick(&myNoise));
		//filtNoise = tVZFilter_tickEfficient(&noiseFilt2, filtNoise);
		float slideNoise = filtNoise * barDelta * knobScaled[1] * 10.0f;

		temp += pickupNonLinearity(tSimpleLivingString3_tick(&livStr[i], slideNoise));
	}

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	//float volIdx = LEAF_clip(0.0f, ((volumeSmoothed * 80.0f)), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;

	//temp = input;
	temp *= outVol * masterVolFromBrain;

	return temp;
}



