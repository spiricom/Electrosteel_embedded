/*
 * synth.c
 *
 *  Created on: Dec 27, 2023
 *      Author: jeffsnyder
 */


#include "main.h"
#include "leaf.h"
#include "codec.h"
#include "i2c.h"
#include "gpio.h"
#include "spi.h"
#include "parameters.h"
#include "audiostream.h"
#include "arm_math.h"
#include "synth.h"


#define OVERSAMPLE 2
float inv_oversample = 1.0f / OVERSAMPLE;


uint32_t prevOversample;


float oversamplerArray[OVERSAMPLE];

arm_fir_interpolate_instance_f32 osI[NUM_STRINGS_PER_BOARD];
arm_fir_decimate_instance_f32 osD[NUM_STRINGS_PER_BOARD];
float intState[NUM_STRINGS_PER_BOARD][16];
float decState[NUM_STRINGS_PER_BOARD][33];


float transpose = 0.0f;

//function pointers
shapeTick_t shapeTick[NUM_OSC];
filterTick_t filterTick[NUM_FILT];
lfoShapeTick_t lfoShapeTick[NUM_LFOS];
effectTick_t effectTick[NUM_EFFECT];


//oscillators
tPBSaw saw[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBPulse pulse[NUM_OSC][NUM_STRINGS_PER_BOARD];
tCycle sine[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBTriangle tri[NUM_OSC][NUM_STRINGS_PER_BOARD];

uint8_t oscToTick = NUM_OSC;
uint8_t filterToTick = NUM_FILT;
uint32_t overSampled = 1;
uint8_t numEffectToTick = NUM_EFFECT;


// Using seperate objects for pairs to easily maintain phase relation
tPBSawSquare sawPaired[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBSineTriangle sinePaired[NUM_OSC][NUM_STRINGS_PER_BOARD];
uint8_t oscOn[NUM_OSC];
uint8_t noiseOn;


//noise
float noiseOuts[2][NUM_STRINGS_PER_BOARD];

tVZFilterLS noiseShelf1[NUM_STRINGS_PER_BOARD];
tVZFilterHS noiseShelf2[NUM_STRINGS_PER_BOARD];
tVZFilterBell noiseBell1[NUM_STRINGS_PER_BOARD];
tIntPhasor lfoSaw[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSquareLFO lfoPulse[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tCycle lfoSine[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tTriLFO lfoTri[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSawSquareLFO lfoSawSquare[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSineTriLFO lfoSineTri[NUM_LFOS][NUM_STRINGS_PER_BOARD];
uint8_t lfoOn[NUM_LFOS];


//oscillator outputs
float outSamples[2][NUM_OSC][NUM_STRINGS_PER_BOARD];

//source vals
float sourceValues[NUM_SOURCES][NUM_STRINGS_PER_BOARD];

tExpSmooth mapSmoothers[MAX_NUM_MAPPINGS][NUM_STRINGS_PER_BOARD];
tExpSmooth pitchSmoother[NUM_OSC][NUM_STRINGS_PER_BOARD];
tExpSmooth filterCutoffSmoother[NUM_FILT][NUM_STRINGS_PER_BOARD];



float freqMult[NUM_OSC][NUM_STRINGS_PER_BOARD];
float midiAdd[NUM_OSC][NUM_STRINGS_PER_BOARD];
float bendRangeMultiplier = 0.002929866324849f; //default to divide by 48


//filters
tDiodeFilter diodeFilters[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterBell VZfilterPeak[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterLS VZfilterLS[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterHS VZfilterHS[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilter VZfilterBR[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF lowpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF highpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF bandpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tLadderFilter Ladderfilter[NUM_FILT][NUM_STRINGS_PER_BOARD];

float filterGain[NUM_FILT][NUM_STRINGS_PER_BOARD];

//envelopes
tADSRT envs[NUM_ENV][NUM_STRINGS_PER_BOARD];
uint8_t envOn[NUM_ENV];


//effects
 tHighpass dcBlock1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tHighpass dcBlock2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterLS shelf1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterHS shelf2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterBell bell1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCompressor comp[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCrusher bc[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLockhartWavefolder wf[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLinearDelay delay1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLinearDelay delay2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCycle mod1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCycle mod2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float fxMix[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float fxPostGain[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tDiodeFilter FXdiodeFilters[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterBell FXVZfilterPeak[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterLS FXVZfilterLS[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterHS FXVZfilterHS[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilter FXVZfilterBR[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tTapeDelay tapeDelay[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tFeedbackLeveler feedbackControl[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXlowpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXhighpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXbandpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLadderFilter FXLadderfilter[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float delayFB[NUM_EFFECT][NUM_STRINGS_PER_BOARD];

 tSVF finalLowpass[NUM_STRINGS_PER_BOARD];

 uint8_t voiceSounding = 0;

 uint8_t randomValPointer = 0;

 float oscOuts[2][NUM_OSC][NUM_STRINGS_PER_BOARD];
 float oscAmpMult = 1.0f;
 float oscAmpMultArray[4] = {0.0f, 1.0f, 0.5f, 0.333333f};
 uint32_t timeFilt = 0;
 uint32_t timeTick = 0;
 uint32_t timeMap = 0;
 uint32_t timeOS = 0;
 uint32_t timeSmoothing = 0;
 uint32_t timeGettingNote = 0;
 uint32_t timeNoise = 0;
 uint32_t timePerStringTick = 0;
 uint32_t timeLFO = 0;
 uint32_t timeEnv = 0;
 uint32_t timeOsc = 0;
 uint32_t oscCountdown = 0;
void audioInitSynth()
{
	for (int v = 0; v < NUM_STRINGS_PER_BOARD; v++)
	{

		for(int i = 0; i < NUM_OSC; i++)
		{
			tPBSaw_init(&saw[i][v], &leaf);

			tPBPulse_init(&pulse[i][v], &leaf);

			tCycle_init(&sine[i][v],  &leaf);

			tPBTriangle_init(&tri[i][v],  &leaf);

			tPBSawSquare_init(&sawPaired[i][v], &leaf);

			tPBSineTriangle_init(&sinePaired[i][v],&leaf);

			tExpSmooth_init(&pitchSmoother[i][v], 64.0f, 0.005f, &leaf);

			freqMult[i][v] = 1.0f;
			midiAdd[i][v] = 0.0f;

		}
		for (int i = 0; i < NUM_FILT; i++)
		{
			tSVF_init(&lowpass[i][v], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
			tSVF_init(&highpass[i][v], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
			tSVF_init(&bandpass[i][v], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
			tDiodeFilter_init(&diodeFilters[i][v], 2000.f, 0.5f, &leaf);
			tVZFilterBell_init(&VZfilterPeak[i][v], 2000.f, 1.9f, 1.0f, &leaf);
			tVZFilterLS_init(&VZfilterLS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterHS_init(&VZfilterHS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilter_init(&VZfilterBR[i][v], BandReject, 2000.f, 1.0f, &leaf);
			tLadderFilter_init(&Ladderfilter[i][v], 2000.f, 1.0f, &leaf);
			tExpSmooth_init(&filterCutoffSmoother[i][v], 64.0f, 0.01f, &leaf);
		}

		for (int i = 0; i < NUM_LFOS; i++)
		{
			tIntPhasor_init(&lfoSaw[i][v], &leaf);
			tSquareLFO_init(&lfoPulse[i][v], &leaf);
			tCycle_init(&lfoSine[i][v], &leaf);
			tTriLFO_init(&lfoTri[i][v], &leaf);

			tSineTriLFO_init(&lfoSineTri[i][v], &leaf);
			tSawSquareLFO_init(&lfoSawSquare[i][v], &leaf);
		}


		for (int i = 0; i < NUM_ENV; i++)
		{
			tADSRT_init(&envs[i][v], 0.1f,1000.f,0.5f,1.0f,decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);
			tADSRT_setLeakFactor(&envs[i][v], ((1.0f - 0.1f) * 0.00005f) + 0.99995f);
		}

		//noise
		tVZFilterLS_init(&noiseShelf1[v], 80.0f, 0.5f, 1.0f, &leaf);
		tVZFilterHS_init(&noiseShelf2[v], 12000.0f, 0.5f, 1.0f, &leaf);
		tVZFilterBell_init(&noiseBell1[v],1000.0f, 1.9f, 1.09f, &leaf);

		for (int i = 0; i < NUM_EFFECT; i++)
		{
			tCrusher_init(&bc[i][v],&leaf);
			tHighpass_init(&dcBlock1[i][v], 5.0f,&leaf);
			tHighpass_setSampleRate(&dcBlock1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tHighpass_init(&dcBlock2[i][v], 5.0f,&leaf);
			tHighpass_setSampleRate(&dcBlock2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterLS_init(&shelf1[i][v], 80.0f, 0.5f, 1.0f,&leaf);
			tVZFilterLS_setSampleRate(&shelf1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterHS_init(&shelf2[i][v], 12000.0f, 0.5f, 1.0f, &leaf);
			tVZFilterHS_setSampleRate(&shelf2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterBell_init(&bell1[i][v], 1000.0f, 1.9f, 1.0f, &leaf);
			tVZFilterBell_setSampleRate(&bell1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCompressor_init(&comp[i][v], &leaf);
			tCompressor_setTables(&comp[i][v], atoDbTable, dbtoATable, 0.00001f, 4.0f, -90.0f, 30.0f, ATODB_TABLE_SIZE, DBTOA_TABLE_SIZE);
			tCompressor_setSampleRate(&comp[i][v], SAMPLE_RATE * OVERSAMPLE);
			//tLinearDelay_initToPool(&delay1[i][v], 4000.0f, 4096, &largePool);
			//tLinearDelay_initToPool(&delay2[i][v], 4000.0f, 4096, &largePool);
			tCycle_init(&mod1[i][v], &leaf);
			tCycle_setSampleRate(&mod1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCycle_init(&mod2[i][v], &leaf);
			tCycle_setSampleRate(&mod2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCycle_setFreq(&mod1[i][v], 0.2f);
			tCycle_setFreq(&mod2[i][v], 0.22222222222f);

	        //tTapeDelay_initToPool(&tapeDelay[i][v], 15000.0f, 30000, &largePool);
	        tFeedbackLeveler_init(&feedbackControl[i][v], .99f, 0.01f, 0.125f, 0, &leaf);

			//filters
			tSVF_init(&FXlowpass[i][v], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXlowpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tSVF_init(&FXhighpass[i][v], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXhighpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tSVF_init(&FXbandpass[i][v], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXbandpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tDiodeFilter_init(&FXdiodeFilters[i][v], 2000.f, 1.0f, &leaf);
			tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterBell_init(&FXVZfilterPeak[i][v], 2000.f, 1.6f, 1.0f, &leaf);
			tVZFilterBell_setSampleRate(&FXVZfilterPeak[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterLS_init(&FXVZfilterLS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterLS_setSampleRate(&FXVZfilterLS[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterHS_init(&FXVZfilterHS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterHS_setSampleRate(&FXVZfilterHS[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilter_init(&FXVZfilterBR[i][v], BandReject, 2000.f, 1.0f, &leaf);
			tVZFilter_setSampleRate(&FXVZfilterBR[i][v], SAMPLE_RATE * OVERSAMPLE);
			tLadderFilter_init(&FXLadderfilter[i][v], 2000.f, 1.0f, &leaf);
			tLadderFilter_setSampleRate(&FXLadderfilter[i][v], SAMPLE_RATE * OVERSAMPLE);
		}

		for (int i = 0; i < MAX_NUM_MAPPINGS; i++)
		{
			tExpSmooth_init(&mapSmoothers[i][v], 0.0f, 0.005f, &leaf);
		}

		arm_fir_interpolate_init_f32(&osI[v],2,32,__leaf_table_fir2XLow, intState[v],1);
		arm_fir_decimate_init_f32(&osD[v],32, 2,__leaf_table_fir2XLow, decState[v],2);

		tSVF_init(&finalLowpass[v], SVFTypeLowpass, 19000.f, 0.3f, &leaf);
	}

}

void  audioFreeSynth()
{

}
void __ATTR_ITCMRAM audioFrameSynth(uint16_t buffer_offset)
{
	//HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;

	if (resetStringInputs)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			//note off
			for (int v = 0; v < NUM_ENV; v++)
			{
				tADSRT_clear(&envs[v][i]);
				previousStringInputs[i] = 0;
			}
		}
		resetStringInputs = 0;
	}
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;
				stringOctave[i] = octave;
				//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);

				for (int v = 0; v < NUM_ENV; v++)
				{
					if (envOn[v])
					{
						param* envParams = &params[ENVELOPE_PARAMS_OFFSET + v * EnvelopeParamsNum];
						float useVelocity = envParams[EnvelopeVelocity].realVal[i];
						float envVel = amplitz;
						if (useVelocity == 0) envVel = 1.f;
						tADSRT_on(&envs[v][i], envVel);
						voiceSounding = 1;
					}
				}
				for (int v = 0; v < NUM_LFOS; v++)
				{
					if (lfoOn[v])
					{
						param* lfoParams = &params[LFO_PARAMS_OFFSET + v * LFOParamsNum];
						float noteOnSync = lfoParams[LFOSync].realVal[i];
						if (noteOnSync > 0.5f)
						{
							lfoParams[LFOPhase].setParam(lfoParams[LFOPhase].realVal[i], v, i);
						}
					}
				}
				//sample and hold noise
				sourceValues[RANDOM_SOURCE_OFFSET][i] = (random_values[randomValPointer++] * 0.5f) + 0.5f; // scale between zero and one
				sourceValues[VELOCITY_SOURCE_OFFSET][i] = amplitz;

			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				for (int v = 0; v < NUM_ENV; v++)
				{
					if (envOn[v])
					{
						tADSRT_off(&envs[v][i]);
					}
				}
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}
	//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		current_sample = (int32_t)(audioTickSynth() * TWO_TO_23);
		audioOutBuffer[buffer_offset + i] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;
	}



	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;

	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;
	if (frameLoadPercentage > .99f)
	{
		frameLoadOverCount++;
		if (frameLoadOverCount > 3)
		{

			if (overSampled == 1)
			{
				overSampled = 0;
				changeOversampling(overSampled);
			}
			else if (oscToTick > 0)
			{
				oscToTick--;
			}
		}
	}
	//HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
}



float __ATTR_ITCMRAM audioTickSynth(void)
{
	uint32_t tempCountTick = DWT->CYCCNT;
	float masterSample = 0.0f;

	//run mapping ticks for all strings
	uint32_t tempCountMap = DWT->CYCCNT;
	tickMappings();
	timeMap = DWT->CYCCNT - tempCountMap;

	uint32_t tempSmoothing = DWT->CYCCNT;
	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			sourceValues[MACRO_SOURCE_OFFSET + i][v] = knobScaled[i];
		}
	}
	for (int i = 0; i < 10; i++)
	{
		pedalScaled[i] = tExpSmooth_tick(&pedalSmoothers[i]);
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			sourceValues[PEDAL_SOURCE_OFFSET + i][v] = pedalScaled[i];
		}
	}
	for (int v = 0; v < numStringsThisBoard; v++)
	{
		sourceValues[EXPRESSION_PEDAL_SOURCE_OFFSET][v] = volumePedal;
	}
	timeSmoothing = DWT->CYCCNT - tempSmoothing;

	float note[numStringsThisBoard];
	uint32_t tempPerStringTick = DWT->CYCCNT;
	for (int v = 0; v < numStringsThisBoard; v++)
	{
		float sample = 0.0f;

		uint32_t tempCountGettingNote = DWT->CYCCNT;
		note[v] = stringMIDIPitches[v] + stringOctave[v];
		sourceValues[MIDI_KEY_SOURCE_OFFSET][v] = (note[v] - midiKeySubtractor) * midiKeyDivisor;

		if (note[v] < 0.0f)
		{
			note[v] = 0.0f;
		}
		if (note[v] > 127.0f)
		{
			note[v] = 127.0f;
		}
		if (isnan(note[v]))
		{
			note[v] = 64.0f;
		}
		timeGettingNote = DWT->CYCCNT - tempCountGettingNote;

		uint32_t tempCountEnv = DWT->CYCCNT;
		envelope_tick(v);
		timeEnv = DWT->CYCCNT - tempCountEnv;

		uint32_t tempCountLFO = DWT->CYCCNT;
		lfo_tick(v);
		timeLFO = DWT->CYCCNT - tempCountLFO;

		uint32_t tempCountOsc = DWT->CYCCNT;
		oscillator_tick(note[v], v);
		timeOsc = DWT->CYCCNT - tempCountOsc;

		uint32_t tempCountNoise = DWT->CYCCNT;
		if (noiseOn)
		{
			noise_tick(v);
		}
		timeNoise = DWT->CYCCNT - tempCountNoise;

		float filterSamps[2] = {0.0f, 0.0f};
		for (int i = 0; i < oscToTick; i++)
		{
			filterSamps[0] += oscOuts[0][i][v];
			filterSamps[1] += oscOuts[1][i][v];
		}
		filterSamps[0] += noiseOuts[0][v];
		filterSamps[1] += noiseOuts[1][v];

		uint32_t tempCountFilt = DWT->CYCCNT;
		sample = filter_tick(&filterSamps[0], note[v], v);
		timeFilt = DWT->CYCCNT - tempCountFilt;

		if (fxPre)
		{
			sample *= amplitude[v];
		}
		uint32_t tempCountOS = DWT->CYCCNT;

		if (overSampled)
		{

			//oversample for non-linear effects (distortion, etc)
			//using the arm interpolation and decimation cuts 100 cycles off of the processing
			arm_fir_interpolate_f32(&osI[v], &sample, (float*)&oversamplerArray, 1);


			for (int i = 0; i < 4; i++)
			{
				if (effectsActive[i])
				{
					for (int j = 0; j < OVERSAMPLE; j++)
					{
						float dry = oversamplerArray[j]; //store the dry value to mix later
						oversamplerArray[j] = effectTick[i](oversamplerArray[j], i, v); //run the effect
						oversamplerArray[j] = ((1.0f - fxMix[i][v]) * dry) + (fxMix[i][v] * oversamplerArray[j]); //mix in dry/wet at the "mix" amount
						oversamplerArray[j] *= fxPostGain[i][v]; //apply postgain
					}
				}
			}
			//downsample to get back to normal sample rate
			arm_fir_decimate_f32(&osD[v], (float*)&oversamplerArray, &sample, 2);
		}
		else
		{
			for (int i = 0; i < NUM_EFFECT; i++)
			{
				if (effectsActive[i])
				{
					float dry = sample;
					sample = effectTick[i](sample, i, v); //run the effect
					sample =((1.0f - fxMix[i][v]) * dry) + (fxMix[i][v] * sample);
					sample *= fxPostGain[i][v];
				}
			}
		}

		timeOS = DWT->CYCCNT - tempCountOS;

		if (!fxPre)
		{
			sample *= amplitude[v];
		}

		sample = tSVF_tick(&finalLowpass[v], sample) * masterVolFromBrainForSynth;
		masterSample += sample;// * finalMaster[v];
	}
	timePerStringTick = DWT->CYCCNT - tempPerStringTick;

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;

	if (pedalControlsMaster)
	{
		masterSample *= outVol;
	}
	if (masterSample  > .999999f)
	{
		masterSample  = .999999f;
		sampleClippedCountdown = 65535;
	}
	else if (masterSample < -.999999f)
	{
		masterSample = -.9999999f;
		sampleClippedCountdown = 65535;
	}
	else
	{
		if (sampleClippedCountdown > 0)
		{
			sampleClippedCountdown--;
		}
	}
	timeTick = DWT->CYCCNT - tempCountTick;

	return masterSample * audioMasterLevel * 0.98f;
}



void changeOversampling(uint32_t newOS)
{
	if (newOS != prevOversample)
	{
		uint32_t osMult = (newOS + 1) * SAMPLE_RATE; // change os to 1-2 range
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			for (int i = 0; i < NUM_EFFECT; i++)
			{
				tHighpass_setSampleRate(&dcBlock1[i][v], osMult);
				tHighpass_setSampleRate(&dcBlock2[i][v], osMult);
				tVZFilterLS_setSampleRate(&shelf1[i][v], osMult);
				tVZFilterLS_setFreqFast(&shelf1[i][v], shelf1[i][v]->cutoffMIDI);
				tVZFilterHS_setSampleRate(&shelf2[i][v], osMult);
				tVZFilterHS_setFreqFast(&shelf2[i][v], shelf2[i][v]->cutoffMIDI);
				tVZFilterBell_setSampleRate(&bell1[i][v], osMult);
				tVZFilterBell_setFreqFast(&bell1[i][v], bell1[i][v]->cutoffMIDI);
				tCompressor_setSampleRate(&comp[i][v], osMult);
				tCycle_setSampleRate(&mod1[i][v], osMult);
				tCycle_setSampleRate(&mod2[i][v], osMult);
				tSVF_setSampleRate(&FXlowpass[i][v],osMult);
				tSVF_setFreqFast(&FXlowpass[i][v], FXlowpass[i][v]->cutoffMIDI);
				tSVF_setSampleRate(&FXhighpass[i][v],osMult);
				tSVF_setFreqFast(&FXhighpass[i][v], FXhighpass[i][v]->cutoffMIDI);
				tSVF_setSampleRate(&FXbandpass[i][v],osMult);
				tSVF_setFreqFast(&FXbandpass[i][v], FXbandpass[i][v]->cutoffMIDI);
				tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], osMult);
				tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], FXdiodeFilters[i][v]->cutoffMIDI);
				tVZFilterBell_setSampleRate(&FXVZfilterPeak[i][v], osMult);
				tVZFilterBell_setFreqFast(&FXVZfilterPeak[i][v], FXVZfilterPeak[i][v]->cutoffMIDI);
				tVZFilterLS_setSampleRate(&FXVZfilterLS[i][v], osMult);
				tVZFilterLS_setFreqFast(&FXVZfilterLS[i][v], FXVZfilterLS[i][v]->cutoffMIDI);
				tVZFilterHS_setSampleRate(&FXVZfilterHS[i][v], osMult);
				tVZFilterHS_setFreqFast(&FXVZfilterHS[i][v], FXVZfilterHS[i][v]->cutoffMIDI);
				tVZFilter_setSampleRate(&FXVZfilterBR[i][v], osMult);
				tVZFilter_setFreq(&FXVZfilterBR[i][v], FXVZfilterBR[i][v]->fc);
				tLadderFilter_setSampleRate(&FXLadderfilter[i][v], osMult);
				tLadderFilter_setFreqFast(&FXLadderfilter[i][v], FXLadderfilter[i][v]->cutoffMIDI);
			}
		}
	}
	prevOversample = newOS;
}
