/*
 * audiostream.c
 *
 *  Created on: Aug 30, 2019
 *      Author: jeffsnyder
 */


/* Includes ------------------------------------------------------------------*/

#include "main.h"
#include "leaf.h"
#include "codec.h"
#include "i2c.h"
#include "gpio.h"
#include "spi.h"
#include "parameters.h"
#include "audiostream.h"
#include "arm_math.h"
#include "string1.h"
#include "string2.h"
#include "additive.h"
#include "vocal.h"
#include "synth.h"

//the audio buffers are put in the D2 RAM area because that is a memory location that the DMA has access to.
int32_t audioOutBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2_DMA;
int32_t audioInBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2_DMA;


char small_memory[SMALL_MEM_SIZE];
char medium_memory[MED_MEM_SIZE] __ATTR_RAM_D1;
char large_memory[LARGE_MEM_SIZE] __ATTR_SDRAM;
tMempool mediumPool;
tMempool largePool;

HAL_StatusTypeDef transmit_status;
HAL_StatusTypeDef receive_status;

uint32_t codecReady = 0;

uint32_t frameCounter = 0;

volatile int stringPositions[2];
volatile int stringPositionsPrev[2];

volatile uint32_t newPluck = 0 ;
volatile uint32_t newBar = 0 ;



uint8_t numStrings = 10;

volatile uint16_t previousStringInputs[12];

float volumeAmps128[128] = {0.000562, 0.000569, 0.000577, 0.000580, 0.000587, 0.000601, 0.000622, 0.000650, 0.000676, 0.000699, 0.000720, 0.000739, 0.000753, 0.000766, 0.000791, 0.000826, 0.000872, 0.000912, 0.000953, 0.001012, 0.001091, 0.001188, 0.001270, 0.001360, 0.001465, 0.001586, 0.001717, 0.001829, 0.001963, 0.002118, 0.002295, 0.002469, 0.002636, 0.002834, 0.003063, 0.003322, 0.003496, 0.003750, 0.004143, 0.004675, 0.005342, 0.005880, 0.006473, 0.007122, 0.007827, 0.008516, 0.009167, 0.009968, 0.010916, 0.012014, 0.012944, 0.013977, 0.015352, 0.017070, 0.019130, 0.020965, 0.022847, 0.024823, 0.026891, 0.028835, 0.030496, 0.033044, 0.036478, 0.040799, 0.045093, 0.049150, 0.053819, 0.059097, 0.064986, 0.070712, 0.076315, 0.081930, 0.087560, 0.093117, 0.098283, 0.104249, 0.111012, 0.118575, 0.124879, 0.131163, 0.141721, 0.156554, 0.175663, 0.195870, 0.213414, 0.228730, 0.241817, 0.252675, 0.264038, 0.276776, 0.290871, 0.306323, 0.322794, 0.338528, 0.353711, 0.368343, 0.382424, 0.393015, 0.406556, 0.426763, 0.453639, 0.487182, 0.522242, 0.550876, 0.573000, 0.588613, 0.598943, 0.613145, 0.628104, 0.643820, 0.660293, 0.676658, 0.692845, 0.709881, 0.727766, 0.746500, 0.764505, 0.782949, 0.802346, 0.822696, 0.844189, 0.867268, 0.886360, 0.901464, 0.912581, 0.921606, 0.932834, 0.944061};

BOOL bufferCleared = TRUE;

int numBuffersToClearOnLoad = 2;
int numBuffersCleared = 0;

float masterVolFromBrain = 0.5f;
float masterVolFromBrainForSynth = 0.25f;

volatile int firstString = 0;
volatile int lastString = 0;
volatile int lastStringPlusOne = 0;


float mtofTable[MTOF_TABLE_SIZE]__ATTR_RAM_D2;

float atoDbTable[ATODB_TABLE_SIZE]__ATTR_RAM_D2;
float dbtoATable[DBTOA_TABLE_SIZE]__ATTR_RAM_D2;


float barInMIDI[2] ;
float prevBarInMIDI[2] ;


uint8_t numStringsThisBoard = NUM_STRINGS_PER_BOARD;

tExpSmooth stringFreqSmoothers[NUM_STRINGS_PER_BOARD];

tExpSmooth volumeSmoother;
tExpSmooth knobSmoothers[12];
tExpSmooth pedalSmoothers[10];
tExpSmooth barSlideSmoother[NUM_STRINGS_PER_BOARD];
tEnvelopeFollower barNoiseSmoother[NUM_STRINGS_PER_BOARD];





uint8_t lsDecay[NUM_STRINGS_PER_BOARD];



audioFrame_t audioFrameFunction;






//envelope tables
float decayExpBuffer[DECAY_EXP_BUFFER_SIZE];
float decayExpBufferSizeMinusOne;


//master
float amplitude[NUM_STRINGS_PER_BOARD];
float finalMaster[NUM_STRINGS_PER_BOARD];



tNoise noise[NUM_STRINGS_PER_BOARD];





LEAF leaf;

union breakFloat{
	float f;
	uint8_t b[4];
};



float prevSamp[NUM_STRINGS_PER_BOARD];

tADSRT fenvelopes[NUM_STRINGS_PER_BOARD];
tADSRT envelopes[NUM_STRINGS_PER_BOARD][3];


tVZFilter noiseFilt;
tVZFilter noiseFilt2;

tNoise myNoise;



float audioInputs[2];

volatile uint8_t whichBar = 0;



float randomFactors[256];



volatile uint16_t stringInputs[NUM_STRINGS];
volatile uint8_t resetStringInputs = 0;

float octave;

float atodbTableScalar;
float atodbTableOffset;
float dbtoaTableScalar;
float dbtoaTableOffset;

float stringMappedPositions[NUM_STRINGS]  = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
float stringFrequencies[NUM_STRINGS] ;

float volumePedal  = 0.0f;
float knobScaled[12];
volatile uint8_t knobFrozen[12];
float pedalScaled[10];
volatile float stringMIDIPitches[NUM_STRINGS_PER_BOARD] ;


volatile int voice = 0 ;
volatile int prevVoice = 127;
int dualSlider = 0;
int neck = 0;

int currentBarBuffer = 0;
int currentPluckBuffer = 0;

int edit = 0;
int whichTable = 0;
int presetReady = 0;
uint8_t whichStringModelLoaded;





//
float stringOctave[NUM_STRINGS_PER_BOARD];
float string1Defaults[12] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.3019f, 0.1764f, 0.7764f, 0.8155f};
float string2Defaults[12] = {0.588158f, 0.15292f, 0.0f, .952854f, 0.34506f, 0.94892f, 0.0f, 0.0f, 0.3019f, 0.1764f, 0.7764f, 0.8155f};

volatile float MIDIerror = 0.0f;

uint8_t interrupted = 0;

uint32_t timeFrame = 0;
float frameLoadPercentage = 0.0f;
float frameLoadMultiplier = 1.0f / (10000.0f * AUDIO_FRAME_SIZE);
uint32_t frameLoadOverCount = 0;

volatile uint16_t sampleClippedCountdown = 0;

volatile uint16_t volumePedalInt;
float octaveRatios[4] = {0.5f, 1.0f, 2.0f, 4.0f};

int octaveIndex = 1;
int stringOctaveIndex[4];

float pluckPos = 0.5f;
volatile int switchStrings = 0;
volatile uint8_t octaveAction = 0;





/**********************************************/

float FORCE_INLINE aToDbTableLookup(float in)
{
    in = fastabsf(in);
    float floatIndex = LEAF_clip (0, (in * atodbTableScalar) - atodbTableOffset, ATODB_TABLE_SIZE_MINUS_ONE);
    uint32_t inAmpIndex = (uint32_t) floatIndex;
    uint32_t inAmpIndexPlusOne = inAmpIndex + 1;
    if (inAmpIndexPlusOne > ATODB_TABLE_SIZE_MINUS_ONE)
    {
    	inAmpIndexPlusOne = ATODB_TABLE_SIZE_MINUS_ONE;
    }
    float alpha = floatIndex - (float)inAmpIndex;
    return ((atoDbTable[inAmpIndex] * (1.0f - alpha)) + (atoDbTable[inAmpIndexPlusOne] * alpha));
}

float FORCE_INLINE aToDbTableLookupFast(float in)
{
    in = fastabsf(in);
    uint32_t inAmpIndex = LEAF_clip (0, (in * atodbTableScalar) - atodbTableOffset, ATODB_TABLE_SIZE_MINUS_ONE);
    return atoDbTable[inAmpIndex];
}

float FORCE_INLINE dbToATableLookup(float in)
{
    float floatIndex = LEAF_clip (0, (in * dbtoaTableScalar) - dbtoaTableOffset, DBTOA_TABLE_SIZE_MINUS_ONE);
    uint32_t inDBIndex = (uint32_t) floatIndex;
    uint32_t inDBIndexPlusOne = inDBIndex + 1;
    if (inDBIndexPlusOne > DBTOA_TABLE_SIZE_MINUS_ONE)
    {
    	inDBIndexPlusOne = DBTOA_TABLE_SIZE_MINUS_ONE;
    }
    float alpha = floatIndex - (float)inDBIndex;
    return ((dbtoATable[inDBIndex] * (1.0f - alpha)) + (dbtoATable[inDBIndexPlusOne] * alpha));
}

float FORCE_INLINE dbToATableLookupFast(float in)
{
    uint32_t inDBIndex = LEAF_clip (0, (in * dbtoaTableScalar) - dbtoaTableOffset, DBTOA_TABLE_SIZE_MINUS_ONE);
    return dbtoATable[inDBIndex];
}



float FORCE_INLINE mtofTableLookup(float tempMIDI)
{
	float tempIndexF = ((LEAF_clip(-163.0f, tempMIDI, 163.0f) * 100.0f) + 16384.0f);
	int tempIndexI = (int)tempIndexF;
	tempIndexF = tempIndexF -tempIndexI;
	float freqToSmooth1 = mtofTable[tempIndexI & 32767];
	float freqToSmooth2 = mtofTable[(tempIndexI + 1) & 32767];
	return ((freqToSmooth1 * (1.0f - tempIndexF)) + (freqToSmooth2 * tempIndexF));
}


void audioInit()
{
	// Initialize LEAF.

	LEAF_init(&leaf, SAMPLE_RATE, small_memory, SMALL_MEM_SIZE, &randomNumber);

	tMempool_init (&mediumPool, medium_memory, MED_MEM_SIZE, &leaf);
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE, &leaf);

	leaf.clearOnAllocation = 1;
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
	decayExpBufferSizeMinusOne = DECAY_EXP_BUFFER_SIZE - 1;

	for (int i = 0; i < 12; i++)
	{
		previousStringInputs[i]	= 0;
	}





	for (int i = 0; i < 256; i++)
	{
		randomFactors[i] = (randomNumber() * 0.4f) + 0.8f;
	}
	LEAF_generate_atodb(atoDbTable, ATODB_TABLE_SIZE, 0.00001f, 1.0f);
	LEAF_generate_dbtoa(dbtoATable, DBTOA_TABLE_SIZE, -90.0f, 50.0f);

	atodbTableScalar = ATODB_TABLE_SIZE_MINUS_ONE/(1.0f-0.00001f);
	atodbTableOffset = 0.00001f * atodbTableScalar;
	dbtoaTableScalar = DBTOA_TABLE_SIZE_MINUS_ONE/(50.0f+90.0f);
	dbtoaTableOffset = -90.0f * dbtoaTableScalar;

	LEAF_generate_mtof(mtofTable, -163.8375f, 163.8375f,  MTOF_TABLE_SIZE); //mtof table for fast calc





	if (numStrings == 6)
	{
		firstString = boardNumber;
		numStringsThisBoard = 1;
	}

	else if (numStrings == 10)
	{
		// first two strings are one board each, other 8 are two strings each.
		if (boardNumber == 0)
		{
			firstString = 0;
			numStringsThisBoard = 1;
		}
		else if (boardNumber == 1)
		{
			firstString = 1;
			numStringsThisBoard = 1;
		}
		else
		{
			firstString = (boardNumber - 1) * NUM_STRINGS_PER_BOARD;
			numStringsThisBoard = 2;
		}
	}

	else //otherwise 12-string version
	{

		firstString = boardNumber * NUM_STRINGS_PER_BOARD;
		numStringsThisBoard = 2;

	}




	tExpSmooth_init(&volumeSmoother,0.0f, 0.0005f, &leaf);
	for (int i = 0; i < 12; i++)
	{
		tExpSmooth_init(&knobSmoothers[i],0.0f, 0.0005f, &leaf);
	}
	for (int i = 0; i < 10; i++)
	{
		tExpSmooth_init(&pedalSmoothers[i],0.0f, 0.0005f, &leaf);
	}

	for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
	{
		tExpSmooth_init(&barSlideSmoother[i],0.000f, 0.01f, &leaf);
		tEnvelopeFollower_init(&barNoiseSmoother[i],0.0001f, 0.9993f, &leaf);
	}

	audioInitAdditive();
	audioInitString1();
	audioInitVocal();
	audioInitSynth();

	for (int v = 0; v < NUM_STRINGS_PER_BOARD; v++)
	{


		tADSRT_init(&fenvelopes[v], 0.0f,  50.0f, 0.0f, 200.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);


		tVZFilter_init(&noiseFilt, BandpassPeak, 1500.0f, 1.5f, &leaf);
		tVZFilter_init(&noiseFilt2, Lowpass, 800.0f, 0.9f, &leaf);
		tVZFilter_setFreq(&noiseFilt2, 3332.0f); //based on testing with knob values


		tVZFilter_setFreq(&noiseFilt, faster_mtof(0.9f * 128.0f));
		tVZFilter_setFreq(&noiseFilt2,faster_mtof(0.8f * 128.0f));

		tNoise_init(&myNoise, WhiteNoise, &leaf);

	}

	for (int i = 0; i < AUDIO_BUFFER_SIZE; i++)
	{

			audioOutBuffer[ i] = (int32_t)(0.0f * TWO_TO_23);
	}

	audioFrameFunction = audioFrameSynth;
	HAL_Delay(1);

}

void audioStart(SAI_HandleTypeDef* hsaiOut, SAI_HandleTypeDef* hsaiIn)
{
	HAL_Delay(1);
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
	//receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
}


void __ATTR_ITCMRAM updateStateFromSPIMessage(uint8_t offset)
{
	int modeBit = SPI_LEVERS_RX[24 + offset];

	octaveAction = (modeBit >> 6) & 1;
	dualSlider = (modeBit >> 5) & 1;

	edit = (modeBit >> 4) & 1;
	voice = SPI_LEVERS_RX[25 + offset];



	octave = (((int32_t) (modeBit & 15) - 5 ) * 12.0f);
	//if "octave action" is set to 1, then immediately change octave instead of waiting for new note
	if (octaveAction)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			stringOctave[i] = octave;
		}
	}

	volumePedalInt = ((uint16_t)SPI_LEVERS_RX[26 + offset] << 8) + ((uint16_t)SPI_LEVERS_RX[27 + offset] & 0xff);
	volumePedal = volumePedalInt * 0.0002442002442f;

	stringPositions[whichBar] = ((uint16_t)SPI_LEVERS_RX[28 + offset] << 8) + ((uint16_t)SPI_LEVERS_RX[29 + offset] & 0xff);
	if (stringPositions[whichBar] != stringPositionsPrev[whichBar])
	{
		//HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_SET);
		stringPositionsPrev[whichBar] = stringPositions[whichBar];
		barInMIDI[0] = stringPositions[0] * 0.001953125f;
		barInMIDI[1] = stringPositions[1] * 0.001953125f;
	}
	tExpSmooth_setDest(&volumeSmoother,volumePedal);
}




void __ATTR_ITCMRAM switchStringModel(int which)
{
	if (which == 1)
	{
		if (whichStringModelLoaded != String1Loaded)
		{
			audioFreeString2();
			audioInitString1();
			//load string1 default params:
			for (int i = 0; i < 12; i++)
			{
				tExpSmooth_setValAndDest(&knobSmoothers[i], string1Defaults[i]);
				knobFrozen[i] = 1;
			}
			tVZFilter_setFreq(&noiseFilt2, 3332.0f); //based on testing with knob values

			audioFrameFunction = audioFrameString1;
		}
	}


	else if (which == 2)
	{
		if (whichStringModelLoaded != String2Loaded)
		{
			audioFreeString1();
			audioInitString2();
		}
		//load string2 default params:
		for (int i = 0; i < 12; i++)
		{
			tExpSmooth_setValAndDest(&knobSmoothers[i], string2Defaults[i]);
			knobFrozen[i] = 1;
		}
		audioFrameFunction = audioFrameString2;
	}
	presetReady = 1;
	diskBusy = 0;
	currentActivePreset = voice;

}
















void __ATTR_ITCMRAM oscillator_tick(float note, int string)
{
	for (int i = 0; i < NUM_OSC; i++)
	{
		oscOuts[0][i][string] = 0.0f;
		oscOuts[1][i][string] = 0.0f;
	}
	for (int osc = 0; osc < oscToTick; osc++)
	{
		if (oscOn[osc])
		{
			param* oscParams = &params[OSC_PARAMS_OFFSET + osc * OscParamsNum];

			float fine = oscParams[OscFine].realVal[string];
			float freqOffset= oscParams[OscFreq].realVal[string];
			float shape = oscParams[OscShape].realVal[string];
			float amp = oscParams[OscAmp].realVal[string];
			float filterSend = oscParams[OscFilterSend].realVal[string];
			//int sync = oscParams[OscisSync].realVal[string] > 0.5f; // probably faster than previous roundf version but haven't tested
			float freqToSmooth = (note + (fine*0.01f));
			tExpSmooth_setDest(&pitchSmoother[osc][string], freqToSmooth);

			float tempMIDI = tExpSmooth_tick(&pitchSmoother[osc][string]) + midiAdd[osc][string];


			float finalFreq = (mtofTableLookup(tempMIDI) * freqMult[osc][string]) + freqOffset;

			float sample = 0.0f;


			//shapeTick[osc](&sample, osc, finalFreq, shape, sync, string);
			shapeTick[osc](&sample, osc, finalFreq, shape, 0, string);

			sample *= amp;

			//sourceValues[OSC_SOURCE_OFFSET + osc] = sample; // the define of zero may be wasteful
			sourceValues[osc][string] = sample;

			sample *= oscAmpMult; // divide down gain if more than one oscillator is sounding (computed at preset load)

			oscOuts[0][osc][string] = sample * (filterSend) * oscParams[OscEnabled].realVal[string];
			oscOuts[1][osc][string] = sample * (1.0f - filterSend) * oscParams[OscEnabled].realVal[string];
		}
	}
}


void __ATTR_ITCMRAM  sawSquareTick(float* sample, int v, float freq, float shape, int sync, int string)
{
	tPBSawSquare_setFreq(&sawPaired[v][string], freq);
	tPBSawSquare_setShape(&sawPaired[v][string], shape);
    //if (sync)
    {
    	//tMBSawPulse_sync(&sawPaired[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);

    }
    *sample += tPBSawSquare_tick(&sawPaired[v][string]);
}

void __ATTR_ITCMRAM  sineTriTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBSineTriangle_setFreq(&sinePaired[v][string], freq);
    tPBSineTriangle_setShape(&sinePaired[v][string],shape);
   // if (sync)
   // {
   // 	tPBSineTriangle_sync(&sinePaired[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
   // }
    *sample += tPBSineTriangle_tick(&sinePaired[v][string]);
}

void __ATTR_ITCMRAM  sawTick(float* sample, int v, float freq, float shape, int sync, int string)
{
	tPBSaw_setFreq(&saw[v][string], freq);
    //if (sync)
	//{
	//	tPBSaw_sync(&saw[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBSaw_tick(&saw[v][string]);
}

void __ATTR_ITCMRAM  pulseTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBPulse_setFreq(&pulse[v][string], freq);
    tPBPulse_setWidth(&pulse[v][string], shape);
    //if (sync)
	//{
	//	tPBPulse_sync(&pulse[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBPulse_tick(&pulse[v][string]);
}

void __ATTR_ITCMRAM  sineTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tCycle_setFreq(&sine[v][string], freq);
    *sample += tCycle_tick(&sine[v][string]);
}

void __ATTR_ITCMRAM  triTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBTriangle_setFreq(&tri[v][string], freq);
    tPBTriangle_setSkew(&tri[v][string], shape);
    //if (sync)
	//{
	//	tMBTriangle_sync(&tri[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBTriangle_tick(&tri[v][string]);
}

void __ATTR_ITCMRAM  userTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    //tWaveOscS_setFreq(&wave[v], freq);
    //tWaveOscS_setIndex(&wave[v], shape);
    //*sample += tWaveOscS_tick(&wave[v]);
}



float __ATTR_ITCMRAM filter_tick(float* samples, float note, int string)
{
	float cutoff[2];
	uint8_t enabledFilt[2] = {0,0};
	for (int f = 0; f < NUM_FILT; f++)
	{
		param* filtParams = &params[FILTER_PARAMS_OFFSET + f * FilterParamsNum];
		float enabled = filtParams[FilterEnabled].realVal[string];
		enabledFilt[f] = (enabled > 0.5f);
		if (!enabledFilt[f]) continue;

		float MIDIcutoff = filtParams[FilterCutoff].realVal[string];
		float keyFollow = filtParams[FilterKeyFollow].realVal[string];
		if (isnan(note))
		{
			note = 0.0f; //is this necessary?
		}

		cutoff[f] = MIDIcutoff + (note  * keyFollow);

		//smoothing may not be necessary
		//tExpSmooth_setDest(&filterCutoffSmoother[f][string], cutoff[f]);
		//cutoff[f] = tExpSmooth_tick(&filterCutoffSmoother[f][string]);
	}

	float  sp = params[FilterSeriesParallelMix].realVal[string];

	if (enabledFilt[0])
	{
		filterTick[0](&samples[0], 0, cutoff[0], string);
	}
	float sendToFilter2 = samples[0] * (1.0f - sp);
	samples[1] += sendToFilter2;
	//compute what gets sent to the second filter
	if (enabledFilt[1])
	{
		filterTick[1](&samples[1], 1, cutoff[1], string);
	}
	return samples[1] + (samples[0] * sp);
}


void __ATTR_ITCMRAM  lowpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&lowpass[v][string], cutoff);
	*sample = tSVF_tick(&lowpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  highpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&highpass[v][string], cutoff);
	*sample = tSVF_tick(&highpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  bandpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&bandpass[v][string], cutoff);
	*sample = tSVF_tick(&bandpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  diodeLowpassTick(float* sample, int v, float cutoff, int string)
{
	tDiodeFilter_setFreqFast(&diodeFilters[v][string], cutoff);
	*sample = tDiodeFilter_tickEfficient(&diodeFilters[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  VZpeakTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterBell_setFreq(&VZfilterPeak[v][string], cutoff);
	*sample = tVZFilterBell_tick(&VZfilterPeak[v][string], *sample);
}

void __ATTR_ITCMRAM  VZlowshelfTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterLS_setFreqFast(&VZfilterLS[v][string], cutoff);
	*sample = tVZFilterLS_tick(&VZfilterLS[v][string], *sample);
}
void __ATTR_ITCMRAM  VZhighshelfTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterHS_setFreqFast(&VZfilterHS[v][string], cutoff);
	*sample = tVZFilterHS_tick(&VZfilterHS[v][string], *sample);
}
void __ATTR_ITCMRAM  VZbandrejectTick(float* sample, int v, float cutoff, int string)
{
	tVZFilter_setFreqFast(&VZfilterBR[v][string], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterBR[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  LadderLowpassTick(float* sample, int v, float cutoff, int string)
{
	tLadderFilter_setFreqFast(&Ladderfilter[v][string], cutoff);
	*sample = tLadderFilter_tick(&Ladderfilter[v][string], *sample);
    *sample *= filterGain[v][string];
}


float midiAdd[NUM_OSC][NUM_STRINGS_PER_BOARD];

void __ATTR_ITCMRAM setFreqMultPitch(float pitch, int osc, int string)
{
	pitch *= 24.0f;
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal[string] > 0.5f) ///check for value of 1 since this is a float
	{
		pitch = roundf(pitch);
	}
	midiAdd[osc][string] = pitch;
}

void __ATTR_ITCMRAM setFreqMultHarm(float harm, int osc, int string)
{
	harm *= 15.0f;
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal[string] > 0.5f) ///check for value of 1 since this is a float
	{
		harm = roundf(harm);
	}

	if (harm >= 0)
	{
		freqMult[osc][string] = (harm + 1);
	}
	else
	{
		freqMult[osc][string] = (1.0f / fabsf((harm - 1)));
	}
}




void __ATTR_ITCMRAM  lowpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&lowpass[v][string], q);
}

void __ATTR_ITCMRAM  highpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&highpass[v][string], q);
}

void __ATTR_ITCMRAM  bandpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&bandpass[v][string], q);
}

void __ATTR_ITCMRAM  diodeLowpassSetQ(float q, int v, int string)
{
	tDiodeFilter_setQ(&diodeFilters[v][string], q);
}

void __ATTR_ITCMRAM  VZpeakSetQ(float q, int v, int string)
{
	tVZFilterBell_setBandwidth(&VZfilterPeak[v][string], q);
}

void __ATTR_ITCMRAM  VZlowshelfSetQ(float q, int v, int string)
{
	tVZFilterLS_setResonance(&VZfilterLS[v][string], q);
}

void __ATTR_ITCMRAM  VZhighshelfSetQ(float q, int v, int string)
{
	tVZFilterHS_setResonance(&VZfilterHS[v][string], q);
}

void __ATTR_ITCMRAM  VZbandrejectSetQ(float q, int v, int string)
{
	tVZFilter_setResonance(&VZfilterBR[v][string], q);
}

void __ATTR_ITCMRAM  LadderLowpassSetQ(float q, int v, int string)
{
	tLadderFilter_setQ(&Ladderfilter[v][string], q);
}

void __ATTR_ITCMRAM  lowpassSetGain(float gain, int v, int string)
{
    filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  highpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  bandpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  diodeLowpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  VZpeakSetGain(float gain, int v, int string)
{
	 tVZFilterBell_setGain(&VZfilterPeak[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZlowshelfSetGain(float gain, int v, int string)
{
	tVZFilterLS_setGain(&VZfilterLS[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZhighshelfSetGain(float gain, int v, int string)
{
	tVZFilterHS_setGain(&VZfilterHS[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void  __ATTR_ITCMRAM VZbandrejectSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void  __ATTR_ITCMRAM  LadderLowpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}


void __ATTR_ITCMRAM envelope_tick(int string)
{
	for (int v = 0; v < NUM_ENV; v++)
	{
		if (envOn[v])
		{
			sourceValues[ENV_SOURCE_OFFSET + v][string] = tADSRT_tickNoInterp(&envs[v][string]);
		}
	}
}


void __ATTR_ITCMRAM lfo_tick(int string)
{
	for (int i = 0; i < NUM_LFOS; i++)
	{
		if (lfoOn[i])
		{
			float sample = 0.0f;
			lfoShapeTick[i](&sample,i, string);
			sourceValues[LFO_SOURCE_OFFSET + i][string] = sample;
		}
	}
}


void  __ATTR_ITCMRAM  setEnvelopeAttack(float a, int v, int string)
{
	a = a + 0.001f;
	tADSRT_setAttack(&envs[v][string], a);
}

void  __ATTR_ITCMRAM  setEnvelopeDecay(float d, int v, int string)
{
	d = d + 0.001f;
	tADSRT_setDecay(&envs[v][string], d);
}

void  __ATTR_ITCMRAM  setEnvelopeSustain(float s, int v, int string)
{
	tADSRT_setSustain(&envs[v][string], s);
}

void  __ATTR_ITCMRAM  setEnvelopeRelease(float r, int v, int string)
{
	r = r + 0.001f;
	tADSRT_setRelease(&envs[v][string], r);
}

void  __ATTR_ITCMRAM  setEnvelopeLeak(float leak, int v, int string)
{
	tADSRT_setLeakFactor(&envs[v][string], 0.99995f + 0.00005f*(1.f-leak));
}

void  __ATTR_ITCMRAM  setAmp(float amp, int v, int string)
{
	amplitude[string] = amp;
}

void  __ATTR_ITCMRAM  setMaster(float amp,  int v, int string)
{
	finalMaster[string] = amp;
}

void  __ATTR_ITCMRAM  setTranspose(float in, int v, int string)
{
	transpose = in;
}

void  __ATTR_ITCMRAM  setPitchBendRange(float in, int v, int string)
{
	bendRangeMultiplier = 1.0f / (16383.0f / (in * 2.0f));
}

void  __ATTR_ITCMRAM  setFinalLowpass(float in, int v, int string)
{
	tSVF_setFreqFast(&finalLowpass[string], in);
}


void __ATTR_ITCMRAM tickMappings(void)
{
	interruptChecker = 0;
	for (int i = 0; i < numMappings; i++)
	{
		if (mappings[i].destNumber != 255)
		{
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				float unsmoothedValue = 0.0f;
				float smoothedValue = 0.0f;
				for (int j = 0; j < 3; j++)
				{
					if (mappings[i].hookActive[j])
					{
						float sum = *mappings[i].sourceValPtr[j][v] * mappings[i].amount[j] * *mappings[i].scalarSourceValPtr[j][v];
						if (mappings[i].sourceSmoothed[j])
						{
							smoothedValue += sum;
						}
						else
						{
							unsmoothedValue += sum;
						}
					}
				}
				//sources are now summed - let's add the initial value
				smoothedValue += mappings[i].dest->zeroToOneVal[v];

				tExpSmooth_setDest(&mapSmoothers[i][v], smoothedValue);
				smoothedValue = tExpSmooth_tick(&mapSmoothers[i][v]);
				float finalVal = unsmoothedValue + smoothedValue;

				//now scale the value with the correct scaling function
				mappings[i].dest->realVal[v] = mappings[i].dest->scaleFunc(finalVal);
				//mappings[i].dest->realVal[v] = mappings[i].dest->scaleFunc(unsmoothedValue + mappings[i].dest->zeroToOneVal[v]);
				//and pop that value where it belongs by setting the actual parameter
				mappings[i].dest->setParam(mappings[i].dest->realVal[v], mappings[i].dest->objectNumber, v);
			}
		}
	}


}




void __ATTR_ITCMRAM lfoSawSquareTick(float* sample, int v, int string)
{
	*sample = tSawSquareLFO_tick(&lfoSawSquare[v][string]);
}

void __ATTR_ITCMRAM lfoSineTriTick(float* sample, int v, int string)
{
	*sample = tSineTriLFO_tick(&lfoSineTri[v][string]);
}

void __ATTR_ITCMRAM lfoSineTick(float* sample, int v, int string)
{
    *sample = tCycle_tick(&lfoSine[v][string]);
}

void __ATTR_ITCMRAM lfoTriTick(float* sample, int v, int string)
{
    *sample = tTriLFO_tick(&lfoTri[v][string]);
}
void __ATTR_ITCMRAM lfoSawTick(float* sample, int v, int string)
{
    *sample = (tIntPhasor_tick(&lfoSaw[v][string]) * 2.0f) - 1.0f;
}

void __ATTR_ITCMRAM lfoPulseTick(float* sample, int v, int string)
{
    *sample = tSquareLFO_tick(&lfoPulse[v][string]);
}

void __ATTR_ITCMRAM lfoSawSquareSetRate(float r, int v, int string)
{
	tSawSquareLFO_setFreq(&lfoSawSquare[v][string],r);
}

void __ATTR_ITCMRAM lfoSineTriSetRate(float r, int v, int string)
{
	tSineTriLFO_setFreq(&lfoSineTri[v][string],r);
}
void __ATTR_ITCMRAM lfoSineSetRate(float r, int v, int string)
{
	tCycle_setFreq(&lfoSine[v][string], r);
}
void __ATTR_ITCMRAM lfoTriSetRate(float r, int v, int string)
{
	tTriLFO_setFreq(&lfoTri[v][string], r);
}
void __ATTR_ITCMRAM lfoSawSetRate(float r, int v, int string)
{
	tIntPhasor_setFreq(&lfoSaw[v][string], r);
}
void __ATTR_ITCMRAM lfoPulseSetRate(float r, int v, int string)
{
	 tSquareLFO_setFreq(&lfoPulse[v][string], r);
}


void __ATTR_ITCMRAM lfoSawSquareSetPhase(float p, int v, int string)
{
	tSawSquareLFO_setPhase(&lfoSawSquare[v][string],p);
}
void __ATTR_ITCMRAM lfoSineTriSetPhase(float p, int v, int string)
{
	tSineTriLFO_setPhase(&lfoSineTri[v][string], p);
}
void __ATTR_ITCMRAM lfoSineSetPhase(float p, int v, int string)
{
	tCycle_setPhase(&lfoSine[v][string],p);
}
void __ATTR_ITCMRAM lfoTriSetPhase(float p, int v, int string)
{
	tTriLFO_setPhase(&lfoTri[v][string],p);
}
void __ATTR_ITCMRAM lfoSawSetPhase(float p, int v, int string)
{
	tIntPhasor_setPhase(&lfoSaw[v][string], p);
}
void __ATTR_ITCMRAM lfoPulseSetPhase(float p, int v, int string)
{
	tSquareLFO_setPhase(&lfoPulse[v][string], p);
}


void __ATTR_ITCMRAM lfoSawSquareSetShape(float s, int v, int string)
{
	tSawSquareLFO_setShape(&lfoSawSquare[v][string],s);
}
void __ATTR_ITCMRAM lfoSineTriSetShape(float s, int v, int string)
{
	tSineTriLFO_setShape(&lfoSineTri[v][string],s);
}
void __ATTR_ITCMRAM lfoSineSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoTriSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoSawSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoPulseSetShape(float s, int v, int string)
{
	tSquareLFO_setPulseWidth(&lfoPulse[v][string], s);
}






void __ATTR_ITCMRAM  clipperGainSet(float value, int v, int string)
{
	param1[v][string] = dbToATableLookup(value * 24.0f);
}
void __ATTR_ITCMRAM  wavefolderParam1(float value, int v, int string)
{
	param1[v][string] = dbToATableLookup(value * 12.0f);
}
void __ATTR_ITCMRAM  wavefolderParam3(float value, int v, int string)
{
	//value = (value * 0.99f) + 0.00f; //avoid zero
	invCurFB[v][string] = (1.0f / (1.0f + value));
	param3[v][string] = value;
}

void __ATTR_ITCMRAM  tiltParam1(float value, int v, int string)
{
	tVZFilterLS_setGain(&shelf1[v][string], dbToATableLookup(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilterHS_setGain(&shelf2[v][string], dbToATableLookup((value * 30.0f) - 15.0f));
}

void __ATTR_ITCMRAM  tiltParam2(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilterBell_setFreq(&bell1[v][string], value);
}
void __ATTR_ITCMRAM  tiltParam3(float value, int v, int string)
{
	tVZFilterBell_setBandwidth(&bell1[v][string], (value +1.0f)*6.0f);//TODO: make this match plugin
}
void __ATTR_ITCMRAM  tiltParam4(float value, int v, int string)
{
	tVZFilterBell_setGain(&bell1[v][string], dbToATableLookup((value * 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM  compressorParam1(float value, int v, int string)
{
	comp[v][string]->T = value*-24.0f;
}
void __ATTR_ITCMRAM  compressorParam2(float value, int v, int string)
{
	comp[v][string]->R = ((value*10.0f)+1.0f);
	comp[v][string]->invR  = 1.0f / comp[v][string]->R;
}

void __ATTR_ITCMRAM  compressorParam3(float value, int v, int string)
{
	comp[v][string]->M = value * 18.0f;
}

void __ATTR_ITCMRAM  compressorParam4(float value, int v, int string)
{
	value = (value +  0.001f);
	comp[v][string]->tauAttack = fasterexpf(-1.0f/(value * comp[v][string]->sampleRate));
}

void __ATTR_ITCMRAM  compressorParam5(float value, int v, int string)
{
	value = (value + 0.001f);
	comp[v][string]->tauRelease = fasterexpf(-1.0f/(value * comp[v][string]->sampleRate));
}

void __ATTR_ITCMRAM  offsetParam2(float value, int v, int string)
{
	param2[v][string] = (value * 2.0f) - 1.0f;
}
void __ATTR_ITCMRAM param2Linear(float value, int v, int string)
{
	param2[v][string] = value;
}
void __ATTR_ITCMRAM param3Linear(float value, int v, int string)
{
	param3[v][string] = value;
}
void __ATTR_ITCMRAM param3Soft(float value, int v, int string)
{
	param3[v][string] = (value * .99f) + 0.01f;
	shapeDividerS[v][string] = 1.0f / (param3[v][string] - ((param3[v][string]*param3[v][string]*param3[v][string]) * 0.3333333f));
}

void __ATTR_ITCMRAM param3Hard(float value, int v, int string)
{
	param3[v][string] = ((value * .99f) + 0.01f) * HALF_PI;
	float tempDiv = arm_sin_f32(param3[v][string]);
	if (tempDiv == 0.0f)
	{
		tempDiv = 0.001f;
	}
	shapeDividerH[v][string] = 1.0f/tempDiv;
}

void __ATTR_ITCMRAM param3Poly(float value, int v, int string)
{
	param3[v][string] = ((value * .99f) + 0.01f)* HALF_PI;

    float tempDiv = fastSine(param3[v][string]);
    if (tempDiv == 0.0f)
    {
        tempDiv = 0.001f;
    }
    polyDivider[v][string] = 1.0f/tempDiv;
}

void __ATTR_ITCMRAM param4Linear(float value, int v, int string)
{
	param4[v][string] = value;
}

void __ATTR_ITCMRAM param5Linear(float value, int v, int string)
{
	param5[v][string] = value;
}
void __ATTR_ITCMRAM param2BC(float value, int v, int string)
{
	tCrusher_setQuality (&bc[v][string],value);
}
void __ATTR_ITCMRAM param3BC(float value, int v, int string)
{
	value = (value * inv_oversample) + 0.01f;
	tCrusher_setSamplingRatio (&bc[v][string], value);
}
void __ATTR_ITCMRAM param4BC(float value, int v, int string)
{
	tCrusher_setRound(&bc[v][string], value);
}
void __ATTR_ITCMRAM param5BC(float value, int v, int string)
{
	tCrusher_setOperation(&bc[v][string], value);
}



void __ATTR_ITCMRAM fxMixSet(float value, int v, int string)
{
	fxMix[v][string] = value;
}

void __ATTR_ITCMRAM fxPostGainSet(float value, int v, int string)
{
	fxPostGain[v][string] = dbToATableLookup((value * 24.0f) - 12.0f);
}


//got the idea from https://ccrma.stanford.edu/~jatin/ComplexNonlinearities/Wavefolder.html  -JS
//much more efficient than the lockhart, and can be further optimized with lookups
float __ATTR_ITCMRAM wavefolderTick(float sample, int v, int string)
{
    sample = sample * param1[v][string] + ((param2[v][string] * param1[v][string]));
    float curFB = param3[v][string];
    float curFF = param4[v][string];

    //softclip approx for tanh saturation in original code
    float ffSample = sample;
    if (ffSample <= -1.0f)
    {
    	ffSample = -1.0f;
    } else if (ffSample >= 1.0f)
    {
    	ffSample = 1.0f;
    }
    ffSample = ffSample - ((ffSample * ffSample * ffSample)* 0.3333333f);
    ffSample *= 1.499999f;
    float ff = (curFF * ffSample) + ((1.0f - curFF) * sample);

    //softclip approx for tanh saturation in original code
    float fbSample = wfState[v][string];
    if (fbSample <= -1.0f)
    {
    	fbSample = -1.0f;
    } else if (fbSample >= 1.0f)
    {
    	fbSample = 1.0f;
    }
    fbSample = fbSample - ((fbSample * fbSample * fbSample)* 0.3333333f);
    fbSample *= 1.499999f;
    float fb = curFB * fbSample;

    wfState[v][string] = (ff + fb) - param5[v][string] * arm_sin_f32(TWO_PI * sample); //maybe switch for our own sine lookup (avoid the if statements in the CMSIS code)
    sample = wfState[v][string] * invCurFB[v][string];
    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


void __ATTR_ITCMRAM chorusParam1(float value, int v, int string)
{
	param1[v][string] = value * 5780.0f + 10.0f;
}
void __ATTR_ITCMRAM chorusParam2(float value, int v, int string)
{
	param2[v][string] = value * 0.1f;
}

void __ATTR_ITCMRAM chorusParam3(float value, int v, int string)
{
    tCycle_setFreq(&mod1[v][string], (value * 0.4f) + 0.01f);
}

void __ATTR_ITCMRAM chorusParam4(float value, int v, int string)
{
    tCycle_setFreq(&mod2[v][string], (value * 0.4444444f) + 0.011f);
}


void __ATTR_ITCMRAM delayParam1(float value, int v, int string)
{
    tTapeDelay_setDelay(&tapeDelay[v][string], value * 30000.0f + 1.0f);
}

void __ATTR_ITCMRAM delayParam2(float value, int v, int string)
{
	param2[v][string] = LEAF_clip(0.0f, value * 1.1f, 1.1f);
}

void __ATTR_ITCMRAM delayParam3(float value, int v, int string)
{
    tSVF_setFreqFast(&FXlowpass[v][string], (value * 127.0f));
}

void __ATTR_ITCMRAM delayParam4(float value, int v, int string)
{
    tSVF_setFreqFast(&FXhighpass[v][string], (value * 127.0f));
}

void __ATTR_ITCMRAM delayParam5(float value, int v, int string)
{
	param5[v][string] = (value * 1.5f) + 1.0f;
}

float delayTick(float sample, int v, int string)
{
    sample *= param5[v][string];

    sample = sample + (delayFB[v][string] * param2[v][string]);

    sample = fast_tanh5(sample);

    sample = tFeedbackLeveler_tick(&feedbackControl[v][string], sample);

    delayFB[v][string] = tTapeDelay_tick(&tapeDelay[v][string], sample);
    delayFB[v][string] = tSVF_tick(&FXlowpass[v][string], delayFB[v][string]);
    sample = tSVF_tick(&FXhighpass[v][string], delayFB[v][string]);
    sample = fast_tanh5(sample);
    delayFB[v][string] = sample;
    return sample;
}

float __ATTR_ITCMRAM chorusTick(float sample, int v, int string)
{
	tLinearDelay_setDelay(&delay1[v][string], param1[v][string] * .707f * (1.0f + param2[v][string] * tCycle_tick(&mod1[v][string])));
    tLinearDelay_setDelay(&delay2[v][string], param1[v][string] * .5f * (1.0f - param2[v][string] * tCycle_tick(&mod2[v][string])));
    float temp = tLinearDelay_tick(&delay1[v][string], sample) - sample;
    temp += tLinearDelay_tick(&delay2[v][string], sample) - sample;
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
	//float temp = 0.0f;
    return -temp;
}

float __ATTR_ITCMRAM shaperTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    float temp = LEAF_shaper(sample + (param2[v][string] * param1[v][string]),param3[v][string]);
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    return temp;
}

float __ATTR_ITCMRAM blankTick(float sample, int v, int string)
{
    return sample;
}

float __ATTR_ITCMRAM tiltFilterTick(float sample, int v, int string)
{
    sample = tVZFilterLS_tick(&shelf1[v][string], sample);
    sample = tVZFilterHS_tick(&shelf2[v][string], sample);
    sample = tVZFilterBell_tick(&bell1[v][string], sample);
    return sample;
}

float __ATTR_ITCMRAM tanhTick(float sample, int v, int string)
{
    float gain = param1[v][string];
	sample = sample * gain;
    gain = gain * 0.5f;
    //need to do something with shape param
    float temp = tanhf(sample + (param2[v][string]*gain));
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    //temp *= param4[v][string];
    temp = tanhf(temp);
    //temp = tHighpass_tick(&dcBlock2, temp);
    return temp;
}


float __ATTR_ITCMRAM softClipTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    sample = sample + param2[v][string];
    //float shape = param3[v][string];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = (sample) - (((sample * sample * sample))* 0.3333333f);
        //sample = sample * shapeDividerS[v][string];
    }

    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


float __ATTR_ITCMRAM hardClipTick(float sample, int v, int string)
{

    sample = sample * param1[v][string];
    sample = sample + param2[v][string];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = arm_sin_f32(  (arm_sin_f32(sample*param3[v][string]) * shapeDividerH[v][string]) * param3[v][string]);
        sample = sample * shapeDividerH[v][string];
    }

    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


float __ATTR_ITCMRAM polynomialShaperTick(float sample, int v, int string)
{

    sample = sample * param1[v][string];
    sample = sample + param2[v][string];

    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }

	sample = fastSine(  (fastSine(sample*param3[v][string]) * polyDivider[v][string]) * param3[v][string]);
	sample = sample * polyDivider[v][string];


    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}
float __ATTR_ITCMRAM satTick(float sample, int v, int string)
{;
    sample = sample * param1[v][string];
    float temp = (sample + (param2[v][string] * param1[v][string])) / (1.0f + fabs(sample + param2[v][string]));
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    temp = tHighpass_tick(&dcBlock2[v][string], temp);
    temp = LEAF_tanh(temp);
    return temp;
}



float __ATTR_ITCMRAM bcTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    return tCrusher_tick(&bc[v][string], sample);
}


float __ATTR_ITCMRAM compressorTick(float sample, int v, int string)
{
    //return tCompressor_tickWithTableHardKnee(&comp[v][string], sample);
	return tCompressor_tick(&comp[v][string], sample);
}

float __ATTR_ITCMRAM  FXlowpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXlowpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXhighpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXhighpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXbandpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXbandpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXdiodeLowpassTick(float sample, int v, int string)
{
	return tDiodeFilter_tick(&FXdiodeFilters[v][string], sample);
}

float __ATTR_ITCMRAM  FXVZpeakTick(float sample, int v, int string)
{
	return tVZFilterBell_tick(&FXVZfilterPeak[v][string], sample);
}

float __ATTR_ITCMRAM  FXVZlowshelfTick(float sample, int v, int string)
{
	return tVZFilterLS_tick(&FXVZfilterLS[v][string], sample);
}
float __ATTR_ITCMRAM  FXVZhighshelfTick(float sample, int v, int string)
{
	return tVZFilterHS_tick(&FXVZfilterHS[v][string], sample);
}
float __ATTR_ITCMRAM  FXVZbandrejectTick(float sample, int v, int string)
{
	return  tVZFilter_tickEfficient(&FXVZfilterBR[v][string], sample);
}

float __ATTR_ITCMRAM  FXLadderLowpassTick(float sample, int v, int string)
{
	return tLadderFilter_tick(&FXLadderfilter[v][string], sample);
}
//cutoffparams

void  __ATTR_ITCMRAM FXLowpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tSVF_setFreqFast(&FXlowpass[v][string], value);
}
void __ATTR_ITCMRAM FXHighpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tSVF_setFreqFast(&FXhighpass[v][string], value);
}

void __ATTR_ITCMRAM FXBandpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
    tSVF_setFreqFast(&FXbandpass[v][string], value);
}

void __ATTR_ITCMRAM FXDiodeParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tDiodeFilter_setFreqFast(&FXdiodeFilters[v][string], value);
}
void __ATTR_ITCMRAM FXPeakParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterBell_setFreq(&FXVZfilterPeak[v][string], value);
}
void __ATTR_ITCMRAM FXLowShelfParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
    tVZFilterLS_setFreqFast(&FXVZfilterLS[v][string], value);
}
void __ATTR_ITCMRAM FXHighShelfParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterHS_setFreqFast(&FXVZfilterHS[v][string], value);
}
void __ATTR_ITCMRAM FXNotchParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilter_setFreqFast(&FXVZfilterBR[v][string], value);
}
void __ATTR_ITCMRAM FXLadderParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tLadderFilter_setFreqFast(&FXLadderfilter[v][string], value);
}

//gain params

void __ATTR_ITCMRAM FXPeakParam2(float value, int v, int string)
{
	 tVZFilterBell_setGain(&FXVZfilterPeak[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXLowShelfParam2(float value, int v, int string)
{
	tVZFilterLS_setGain(&FXVZfilterLS[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXHighShelfParam2(float value, int v, int string)
{
	tVZFilterHS_setGain(&FXVZfilterHS[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXNotchParam2(float value, int v, int string)
{
	tVZFilter_setGain(&FXVZfilterBR[v][string], dbToATableLookup((value * 50.f) - 25.f));

}
//resonance params
void __ATTR_ITCMRAM FXLowpassParam3(float value, int v, int string)
{
	tSVF_setQ(&FXlowpass[v][string], value);
}

void __ATTR_ITCMRAM FXHighpassParam3(float value, int v, int string)
{
    tSVF_setQ(&FXhighpass[v][string], value);
}

void __ATTR_ITCMRAM FXBandpassParam3(float value, int v, int string)
{
    tSVF_setQ(&FXbandpass[v][string], value);
}

void __ATTR_ITCMRAM FXDiodeParam3(float value, int v, int string)
{
	tDiodeFilter_setQ(&FXdiodeFilters[v][string], value);
}


void __ATTR_ITCMRAM FXPeakParam3(float value, int v, int string)
{
	tVZFilterBell_setBandwidth(&FXVZfilterPeak[v][string], value);
}


void __ATTR_ITCMRAM FXLowShelfParam3(float value, int v, int string)
{
	tVZFilterLS_setResonance(&FXVZfilterLS[v][string], value);
}


void __ATTR_ITCMRAM FXHighShelfParam3(float value, int v, int string)
{
	tVZFilterHS_setResonance(&FXVZfilterHS[v][string], value);
}


void __ATTR_ITCMRAM FXNotchParam3(float value, int v, int string)
{
	tVZFilter_setResonance(&FXVZfilterBR[v][string], value);
}


void __ATTR_ITCMRAM FXLadderParam3(float value, int v, int string)
{
	tLadderFilter_setQ(&FXLadderfilter[v][string], value);
}




/////NOISE///

void __ATTR_ITCMRAM noiseSetTilt(float value, int v, int string)
{
	tVZFilterLS_setGain(&noiseShelf1[string], dbToATableLookup(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilterHS_setGain(&noiseShelf2[string], dbToATableLookup((value * 30.0f) - 15.0f));
}


void __ATTR_ITCMRAM noiseSetGain(float value, int v, int string)
{
	tVZFilterBell_setGain(&noiseBell1[string], dbToATableLookup((value* 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM noiseSetFreq(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterBell_setFreq(&noiseBell1[string], faster_mtof(value));
	//value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);

}


void __ATTR_ITCMRAM noise_tick(int string)
{
	float enabled = params[Noise].realVal[string];
	float amp = params[NoiseAmp].realVal[string];
	float filterSend = params[NoiseFilterSend].realVal[string];
	amp = amp < 0.f ? 0.f : amp;
	float sample = random_values[randomValPointer++];
	sample = tVZFilterLS_tick(&noiseShelf1[string], sample);
	sample = tVZFilterHS_tick(&noiseShelf2[string], sample);
	sample = tVZFilterBell_tick(&noiseBell1[string], sample);
	sample = sample * amp;
	float normSample = (sample + 1.f) * 0.5f;
	sourceValues[NOISE_SOURCE_OFFSET][string] = normSample;
	noiseOuts[0][string] = sample * filterSend *  enabled;
	noiseOuts[1][string] = sample * (1.f-filterSend) * enabled ;
}




void __ATTR_ITCMRAM HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{
	//if ((!diskBusy)&& (presetReady))
	{
		audioFrameFunction(HALF_BUFFER_SIZE);


	}
	/*
	else
	{
		for (int i = 0; i < HALF_BUFFER_SIZE; i++)
		{
			audioOutBuffer[HALF_BUFFER_SIZE+i] = 0;
		}
	}
	*/
	if (voice != prevVoice)
	{
		if (voice == 63)
		{

			switchStrings = 1;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 62)
		{

			switchStrings = 2;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 61)
		{
			audioFrameFunction = audioFrameAdditive;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else if (voice == 60)
		{
			audioFrameFunction = audioFrameVocal;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else
		{
			audioFrameFunction = audioFrameSynth;
			presetWaitingToLoad = 1;
			presetNumberToLoad = voice;
			presetReady = 0;
			if (prevVoice > 60)
			{
				resetStringInputs = 1;
			}
			frameLoadOverCount = 0;
		}
	}
	prevVoice = voice;
	SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)audioOutBuffer) & ~(uint32_t)0x1F), AUDIO_BUFFER_SIZE+32);
}

void __ATTR_ITCMRAM HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	//if ((!diskBusy)&& (presetReady))
	{
		audioFrameFunction(0);

	}

	/*
	else
	{
		for (int i = 0; i < HALF_BUFFER_SIZE; i++)
		{
			audioOutBuffer[i] = 0;
		}
	}
	*/
	if (voice != prevVoice)
	{
		if (voice == 63)
		{

			switchStrings = 1;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 62)
		{

			switchStrings = 2;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 61)
		{
			audioFrameFunction = audioFrameAdditive;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else if (voice == 60)
		{
			audioFrameFunction = audioFrameVocal;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else
		{
			audioFrameFunction = audioFrameSynth;
			presetWaitingToLoad = 1;
			presetNumberToLoad = voice;
			presetReady = 0;
			if (prevVoice > 60)
			{
				resetStringInputs = 1;
			}
			frameLoadOverCount = 0;
		}
	}
	prevVoice = voice;
	SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)audioOutBuffer) & ~(uint32_t)0x1F), AUDIO_BUFFER_SIZE+32);
}

void __ATTR_ITCMRAM HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
}



