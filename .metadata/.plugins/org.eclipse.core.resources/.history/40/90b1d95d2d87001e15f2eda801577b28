/*
 * audiostream.c
 *
 *  Created on: Aug 30, 2019
 *      Author: jeffsnyder
 */


/* Includes ------------------------------------------------------------------*/

#include "main.h"
#include "leaf.h"
#include "codec.h"
#include "i2c.h"
#include "gpio.h"
#include "spi.h"
#include "parameters.h"
#include "audio.h"
#include "arm_math.h"
//the audio buffers are put in the D2 RAM area because that is a memory location that the DMA has access to.
int32_t audioOutBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2_DMA;
int32_t audioInBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2_DMA;


char small_memory[SMALL_MEM_SIZE];
char medium_memory[MED_MEM_SIZE] __ATTR_RAM_D1;
char large_memory[LARGE_MEM_SIZE] __ATTR_SDRAM;
tMempool mediumPool;
tMempool largePool;

HAL_StatusTypeDef transmit_status;
HAL_StatusTypeDef receive_status;

uint32_t codecReady = 0;

uint32_t frameCounter = 0;

volatile int stringPositions[2];
volatile int stringPositionsPrev[2];

volatile uint32_t newPluck = 0 ;
volatile uint32_t newBar = 0 ;

uint8_t oscToTick = NUM_OSC;
uint8_t filterToTick = NUM_FILT;
uint32_t overSampled = 1;
uint8_t numEffectToTick = NUM_EFFECT;

uint8_t numStrings = 10;

volatile uint16_t previousStringInputs[12];

float volumeAmps128[128] = {0.000562, 0.000569, 0.000577, 0.000580, 0.000587, 0.000601, 0.000622, 0.000650, 0.000676, 0.000699, 0.000720, 0.000739, 0.000753, 0.000766, 0.000791, 0.000826, 0.000872, 0.000912, 0.000953, 0.001012, 0.001091, 0.001188, 0.001270, 0.001360, 0.001465, 0.001586, 0.001717, 0.001829, 0.001963, 0.002118, 0.002295, 0.002469, 0.002636, 0.002834, 0.003063, 0.003322, 0.003496, 0.003750, 0.004143, 0.004675, 0.005342, 0.005880, 0.006473, 0.007122, 0.007827, 0.008516, 0.009167, 0.009968, 0.010916, 0.012014, 0.012944, 0.013977, 0.015352, 0.017070, 0.019130, 0.020965, 0.022847, 0.024823, 0.026891, 0.028835, 0.030496, 0.033044, 0.036478, 0.040799, 0.045093, 0.049150, 0.053819, 0.059097, 0.064986, 0.070712, 0.076315, 0.081930, 0.087560, 0.093117, 0.098283, 0.104249, 0.111012, 0.118575, 0.124879, 0.131163, 0.141721, 0.156554, 0.175663, 0.195870, 0.213414, 0.228730, 0.241817, 0.252675, 0.264038, 0.276776, 0.290871, 0.306323, 0.322794, 0.338528, 0.353711, 0.368343, 0.382424, 0.393015, 0.406556, 0.426763, 0.453639, 0.487182, 0.522242, 0.550876, 0.573000, 0.588613, 0.598943, 0.613145, 0.628104, 0.643820, 0.660293, 0.676658, 0.692845, 0.709881, 0.727766, 0.746500, 0.764505, 0.782949, 0.802346, 0.822696, 0.844189, 0.867268, 0.886360, 0.901464, 0.912581, 0.921606, 0.932834, 0.944061};

BOOL bufferCleared = TRUE;

int numBuffersToClearOnLoad = 2;
int numBuffersCleared = 0;

float masterVolFromBrain = 0.5f;
float masterVolFromBrainForSynth = 0.25f;

volatile int firstString = 0;
volatile int lastString = 0;
volatile int lastStringPlusOne = 0;


float mtofTable[MTOF_TABLE_SIZE]__ATTR_RAM_D2;

float atoDbTable[ATODB_TABLE_SIZE]__ATTR_RAM_D2;
float dbtoATable[DBTOA_TABLE_SIZE]__ATTR_RAM_D2;


float barInMIDI[2] ;
float prevBarInMIDI[2] ;


uint8_t numStringsThisBoard = NUM_STRINGS_PER_BOARD;

tExpSmooth stringFreqSmoothers[NUM_STRINGS_PER_BOARD];

tExpSmooth volumeSmoother;
tExpSmooth knobSmoothers[12];
tExpSmooth pedalSmoothers[10];

tExpSmooth barNoiseSmoother;


uint8_t randomValPointer = 0;


uint8_t lsDecay[NUM_STRINGS_PER_BOARD];

//function pointers
shapeTick_t shapeTick[NUM_OSC];
filterTick_t filterTick[NUM_FILT];
lfoShapeTick_t lfoShapeTick[NUM_LFOS];
effectTick_t effectTick[NUM_EFFECT];

audioFrame_t audioFrameFunction;

//oscillators
tPBSaw saw[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBPulse pulse[NUM_OSC][NUM_STRINGS_PER_BOARD];
tCycle sine[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBTriangle tri[NUM_OSC][NUM_STRINGS_PER_BOARD];

// Using seperate objects for pairs to easily maintain phase relation
tPBSawSquare sawPaired[NUM_OSC][NUM_STRINGS_PER_BOARD];
tPBSineTriangle sinePaired[NUM_OSC][NUM_STRINGS_PER_BOARD];
uint8_t oscOn[NUM_OSC];
uint8_t noiseOn;

//noise
float noiseOuts[2][NUM_STRINGS_PER_BOARD];

tVZFilterLS noiseShelf1[NUM_STRINGS_PER_BOARD];
tVZFilterHS noiseShelf2[NUM_STRINGS_PER_BOARD];
tVZFilterBell noiseBell1[NUM_STRINGS_PER_BOARD];
tIntPhasor lfoSaw[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSquareLFO lfoPulse[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tCycle lfoSine[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tTriLFO lfoTri[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSawSquareLFO lfoSawSquare[NUM_LFOS][NUM_STRINGS_PER_BOARD];
tSineTriLFO lfoSineTri[NUM_LFOS][NUM_STRINGS_PER_BOARD];
uint8_t lfoOn[NUM_LFOS];


//oscillator outputs
float outSamples[2][NUM_OSC][NUM_STRINGS_PER_BOARD];

//source vals
float sourceValues[NUM_SOURCES][NUM_STRINGS_PER_BOARD];

tExpSmooth mapSmoothers[MAX_NUM_MAPPINGS][NUM_STRINGS_PER_BOARD];
tExpSmooth pitchSmoother[NUM_OSC][NUM_STRINGS_PER_BOARD];
tExpSmooth filterCutoffSmoother[NUM_FILT][NUM_STRINGS_PER_BOARD];


float freqMult[NUM_OSC][NUM_STRINGS_PER_BOARD];
float midiAdd[NUM_OSC][NUM_STRINGS_PER_BOARD];
float bendRangeMultiplier = 0.002929866324849f; //default to divide by 48


//filters
tDiodeFilter diodeFilters[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterBell VZfilterPeak[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterLS VZfilterLS[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilterHS VZfilterHS[NUM_FILT][NUM_STRINGS_PER_BOARD];
tVZFilter VZfilterBR[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF lowpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF highpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tSVF bandpass[NUM_FILT][NUM_STRINGS_PER_BOARD];
tLadderFilter Ladderfilter[NUM_FILT][NUM_STRINGS_PER_BOARD];

float filterGain[NUM_FILT][NUM_STRINGS_PER_BOARD];

//envelopes
tADSRT envs[NUM_ENV][NUM_STRINGS_PER_BOARD];
uint8_t envOn[NUM_ENV];

//envelope tables
float decayExpBuffer[DECAY_EXP_BUFFER_SIZE];
float decayExpBufferSizeMinusOne;


//effects
 tHighpass dcBlock1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tHighpass dcBlock2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterLS shelf1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterHS shelf2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterBell bell1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCompressor comp[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCrusher bc[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLockhartWavefolder wf[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLinearDelay delay1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLinearDelay delay2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCycle mod1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tCycle mod2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float fxMix[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float fxPostGain[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tDiodeFilter FXdiodeFilters[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterBell FXVZfilterPeak[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterLS FXVZfilterLS[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilterHS FXVZfilterHS[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tVZFilter FXVZfilterBR[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tTapeDelay tapeDelay[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tFeedbackLeveler feedbackControl[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXlowpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXhighpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tSVF FXbandpass[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 tLadderFilter FXLadderfilter[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
 float delayFB[NUM_EFFECT][NUM_STRINGS_PER_BOARD];

//master
float amplitude[NUM_STRINGS_PER_BOARD];
float finalMaster[NUM_STRINGS_PER_BOARD];


float transpose = 0.0f;
tNoise noise[NUM_STRINGS_PER_BOARD];

#define OVERSAMPLE 2
float inv_oversample = 1.0f / OVERSAMPLE;

float oversamplerArray[OVERSAMPLE];

arm_fir_interpolate_instance_f32 osI[NUM_STRINGS_PER_BOARD];
arm_fir_decimate_instance_f32 osD[NUM_STRINGS_PER_BOARD];
float intState[NUM_STRINGS_PER_BOARD][16];
float decState[NUM_STRINGS_PER_BOARD][33];


tSVF finalLowpass[NUM_STRINGS_PER_BOARD];

uint8_t voiceSounding = 0;

LEAF leaf;

union breakFloat{
	float f;
	uint8_t b[4];
};

//string synth stuff
tSimpleLivingString3 livStr[NUM_STRINGS_PER_BOARD];
tSimpleLivingString5 strings[NUM_STRINGS_PER_BOARD];
float prevSamp[NUM_STRINGS_PER_BOARD];

tADSRT fenvelopes[NUM_STRINGS_PER_BOARD];
tADSRT envelopes[NUM_STRINGS_PER_BOARD][3];


tVZFilter noiseFilt;
tVZFilter noiseFilt2;

tNoise myNoise;

tVoc vocal[NUM_STRINGS_PER_BOARD];

float audioInputs[2];

volatile uint8_t whichBar = 0;

float partials[18] = {0.073f, 0.164f, 0.19f, 0.181f, 0.151f, 0.103f, 0.0684f, 0.053f, 0.046f, 0.032f, 0.024f, 0.021f, 0.0198f, 0.011f, 0.0114f, 0.0137f, 0.0139f, 0.0101f};
float partialsHigh[18] = {0.092f, 0.312f, 0.311f, 0.299f, 0.3125f, 0.13f, 0.054f, 0.028f, 0.012f, 0.0077f, 0.0018f, 0.003f, 0.0024f, 0.002415f, 0.00145f, 0.00103f, 0.0001f, 0.0014f};
float partialDecays[18] = {49.54f, 41.0f, 32.7f, 19.0f, 16.65f, 12.2f, 8.25f, 6.55f, 6.59f, 4.8f, 4.549f, 3.75f, 3.54f, 2.7f, 1.9f, 2.05f, 1.9f, 1.65f};
float partialDecaysHigh[18] = {15.7f, 11.8f, 9.7f, 8.95f, 7.3f, 4.6f, 4.9f, 4.32f, 2.9f, 2.34f, 1.23f, 2.5f, 2.211f, 1.94f, 1.77f, 0.71f, 0.1f, 0.05f};



float stringPartialGains[3][3][12] =
{
		{
				{0.039156f, 0.08295f, 0.100061f, 0.09995f, 0.04556f, 0.0177f, 0.04025f, 0.055531f, 0.051128f, 0.031538f, 0.016563f, 0.0112f},
				{0.151324f, 0.162346f, 0.061834f, 0.06991f, 0.0562f, 0.012482f, 0.014779f, 0.02f, 0.005216f, 0.010173f, 0.0f, 0.0f},
				{0.457762f, 0.17526f, 0.06247f, 0.05275f, 0.01362f, 0.0f, 0.002040f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
		},
		{
				{0.030473f, 0.054897f, 0.065547f, 0.056177f, 0.02957f, 0.02767f, 0.028027f, 0.034652f, 0.026227f, 0.0144f, 0.006086f, 0.0027f},
				{0.102318f, 0.102264f, 0.04869f, 0.056057f, 0.025617f, 0.005731f, 0.04339f, 0.00369f, 0.004151f, 0.002016f, 0.001106f, 0.00528f},
				{0.2387f, 0.080883f, 0.01353f, 0.013997f, 0.004522f, 0.00f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
		},
		{
				{0.05561f, 0.10098f, 0.12085f, 0.095168f, 0.04267f, 0.0135f, 0.014507f, 0.015348f, 0.010175f, 0.005007f, 0.002371f, 0.000964f},
				{0.15764f, 0.225206f, 0.0948f, 0.023891f, 0.007234f, 0.001718f, 0.001173f, 0.00106f, 0.001278f, 0.0f, 0.0f, 0.0f},
				{0.3303f, 0.0314f, 0.002494f, 0.002405f, 0.00362f, 0.000148f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
		}
};
float stringDecays[3][3][12] =
{
		{
				{35.67f, 33.9234f, 18.64f, 15.892f, 12.619274f, 9.99546f, 7.434127f, 5.322585f, 5.60995f, 4.847801f, 3.186f, 2.8237f},
				{12.83f, 8.75f, 7.2341f, 5.26f, 4.023f, 2.43639f, 1.3249f, 2.28643f, 2.086553f, 1.18f, 0.9f, 0.8f},
				{6.422086f, 2.9616f, 1.636757f, 1.549297f, 0.924518f, 0.5f, 0.249887f, 0.1f, 0.05f, 0.05f, 0.05f, 0.05f}
		},
		{
				{23.38936f, 21.62787f, 14.968f, 12.094512f, 7.996f, 6.746f, 7.17174f, 4.94f, 4.28555f, 3.08621f, 2.5488f, 2.04907f},
				{15.018f, 10.320317f, 7.221724f, 6.184f, 3.760794f, 1.94116f, 2.561338f, 2.223991f, 1.574f, 1.0494f, 1.43f, 0.5994f},
				{5.977f, 4.47291f, 1.56f, 1.611f, 1.211950f, 0.9f, 0.8f, 0.6f, 0.5f, 0.4f, 0.3f, 0.2f}
		},
		{
				{15.64294f, 11.2199f, 8.171f, 7.371655f, 5.559978f, 4.685f, 1.91163f, 2.886f, 2.8612f, 2.1999f, 1.774915f, 0.63721},
				{8.17129f, 7.534f, 4.435f, 3.148471f, 1.8866f, 1.17f, 1.13f, 0.9495f, 0.912f, 0.6f, 0.5f, 0.4f},
				{4.635f, 2.298f, 1.1369f, 0.924581f, 0.599f, 0.53725f, 0.4f, 0.3f, 0.2f, 0.2f, 0.2f, 0.1f}
		}
};

float stringFundamentals[3][3] =
{
		{124.0f, 248.0f, 496.0f},
		{204.0f, 408.0f, 816.0f},
		{370.0f, 740.0f, 1480.0f}
};
float dAp[3][2][12];

float dAi[3][2][12];

float dBs[3][2][12];

float randomFactors[256];
tCycle additive[NUM_STRINGS_PER_BOARD][18];
tADSRT additiveEnv[NUM_STRINGS_PER_BOARD][18];

#define NUM_OVERTONES 12
float invNumOvertones;
float decayAf1[18];
float decayBs[18];
float decayAfParts[18];
float totalGain_s[3][3];
float gainNormalizers_s[3][3];
float totalGain[2] = {0.0f, 0.0f};
float gainNormalizers[2] = {0.0f, 0.0f};


volatile uint16_t stringInputs[NUM_STRINGS];
volatile uint8_t resetStringInputs = 0;

float octave;

float atodbTableScalar;
float atodbTableOffset;
float dbtoaTableScalar;
float dbtoaTableOffset;

float stringMappedPositions[NUM_STRINGS]  = {1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
float stringFrequencies[NUM_STRINGS] ;

float volumePedal  = 0.0f;
float knobScaled[12];
volatile uint8_t knobFrozen[12];
float pedalScaled[10];
volatile float stringMIDIPitches[NUM_STRINGS_PER_BOARD] ;

float stringOctave[NUM_STRINGS_PER_BOARD];
volatile int voice = 0 ;
volatile int prevVoice = 127;
int dualSlider = 0;
int neck = 0;

int currentBarBuffer = 0;
int currentPluckBuffer = 0;

int edit = 0;
int whichTable = 0;
int presetReady = 0;
uint8_t whichStringModelLoaded;

tCycle testSine;


float oscOuts[2][NUM_OSC][NUM_STRINGS_PER_BOARD];
float oscAmpMult = 1.0f;
float oscAmpMultArray[4] = {0.0f, 1.0f, 0.5f, 0.333333f};


//

float string1Defaults[12] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.3019f, 0.1764f, 0.7764f, 0.8155f};
float string2Defaults[12] = {0.588158f, 0.15292f, 0.0f, .952854f, 0.34506f, 0.94892f, 0.0f, 0.0f, 0.3019f, 0.1764f, 0.7764f, 0.8155f};

volatile float MIDIerror = 0.0f;
uint32_t timeFilt = 0;
uint32_t timeTick = 0;
uint32_t timeMap = 0;
uint32_t timeOS = 0;
uint32_t timeSmoothing = 0;
uint32_t timeGettingNote = 0;
uint32_t timeNoise = 0;
uint32_t timePerStringTick = 0;
uint32_t timeLFO = 0;
uint32_t timeEnv = 0;
uint32_t timeOsc = 0;
uint32_t oscCountdown = 0;
uint8_t interrupted = 0;
uint32_t timeMIDI = 0;
uint32_t timeFrame = 0;
float frameLoadPercentage = 0.0f;
float frameLoadMultiplier = 1.0f / (10000.0f * AUDIO_FRAME_SIZE);
uint32_t frameLoadOverCount = 0;

volatile uint16_t sampleClippedCountdown = 0;

volatile uint16_t volumePedalInt;
float octaveRatios[4] = {0.5f, 1.0f, 2.0f, 4.0f};

int octaveIndex = 1;
int stringOctaveIndex[4];
const int syncMap[3] = {2, 0, 1};
float pluckPos = 0.5f;
volatile int switchStrings = 0;
volatile uint8_t octaveAction = 0;

uint32_t prevOversample;


float param1[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float param2[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float param3[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float param4[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float param5[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float shapeDividerS[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float shapeDividerH[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float polyDivider[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float wfState[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
float invCurFB[NUM_EFFECT][NUM_STRINGS_PER_BOARD];
/**********************************************/

float FORCE_INLINE aToDbTableLookup(float in)
{
    in = fastabsf(in);
    float floatIndex = LEAF_clip (0, (in * atodbTableScalar) - atodbTableOffset, ATODB_TABLE_SIZE_MINUS_ONE);
    uint32_t inAmpIndex = (uint32_t) floatIndex;
    uint32_t inAmpIndexPlusOne = inAmpIndex + 1;
    if (inAmpIndexPlusOne > ATODB_TABLE_SIZE_MINUS_ONE)
    {
    	inAmpIndexPlusOne = ATODB_TABLE_SIZE_MINUS_ONE;
    }
    float alpha = floatIndex - (float)inAmpIndex;
    return ((atoDbTable[inAmpIndex] * (1.0f - alpha)) + (atoDbTable[inAmpIndexPlusOne] * alpha));
}

float FORCE_INLINE aToDbTableLookupFast(float in)
{
    in = fastabsf(in);
    uint32_t inAmpIndex = LEAF_clip (0, (in * atodbTableScalar) - atodbTableOffset, ATODB_TABLE_SIZE_MINUS_ONE);
    return atoDbTable[inAmpIndex];
}

float FORCE_INLINE dbToATableLookup(float in)
{
    float floatIndex = LEAF_clip (0, (in * dbtoaTableScalar) - dbtoaTableOffset, DBTOA_TABLE_SIZE_MINUS_ONE);
    uint32_t inDBIndex = (uint32_t) floatIndex;
    uint32_t inDBIndexPlusOne = inDBIndex + 1;
    if (inDBIndexPlusOne > DBTOA_TABLE_SIZE_MINUS_ONE)
    {
    	inDBIndexPlusOne = DBTOA_TABLE_SIZE_MINUS_ONE;
    }
    float alpha = floatIndex - (float)inDBIndex;
    return ((dbtoATable[inDBIndex] * (1.0f - alpha)) + (dbtoATable[inDBIndexPlusOne] * alpha));
}

float FORCE_INLINE dbToATableLookupFast(float in)
{
    uint32_t inDBIndex = LEAF_clip (0, (in * dbtoaTableScalar) - dbtoaTableOffset, DBTOA_TABLE_SIZE_MINUS_ONE);
    return dbtoATable[inDBIndex];
}

void changeOversampling(uint32_t newOS)
{
	if (newOS != prevOversample)
	{
		uint32_t osMult = (newOS + 1) * SAMPLE_RATE; // change os to 1-2 range
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			for (int i = 0; i < NUM_EFFECT; i++)
			{
				tHighpass_setSampleRate(&dcBlock1[i][v], osMult);
				tHighpass_setSampleRate(&dcBlock2[i][v], osMult);
				tVZFilterLS_setSampleRate(&shelf1[i][v], osMult);
				tVZFilterLS_setFreqFast(&shelf1[i][v], shelf1[i][v]->cutoffMIDI);
				tVZFilterHS_setSampleRate(&shelf2[i][v], osMult);
				tVZFilterHS_setFreqFast(&shelf2[i][v], shelf2[i][v]->cutoffMIDI);
				tVZFilterBell_setSampleRate(&bell1[i][v], osMult);
				tVZFilterBell_setFreqFast(&bell1[i][v], bell1[i][v]->cutoffMIDI);
				tCompressor_setSampleRate(&comp[i][v], osMult);
				tCycle_setSampleRate(&mod1[i][v], osMult);
				tCycle_setSampleRate(&mod2[i][v], osMult);
				tSVF_setSampleRate(&FXlowpass[i][v],osMult);
				tSVF_setFreqFast(&FXlowpass[i][v], FXlowpass[i][v]->cutoffMIDI);
				tSVF_setSampleRate(&FXhighpass[i][v],osMult);
				tSVF_setFreqFast(&FXhighpass[i][v], FXhighpass[i][v]->cutoffMIDI);
				tSVF_setSampleRate(&FXbandpass[i][v],osMult);
				tSVF_setFreqFast(&FXbandpass[i][v], FXbandpass[i][v]->cutoffMIDI);
				tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], osMult);
				tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], FXdiodeFilters[i][v]->cutoffMIDI);
				tVZFilterBell_setSampleRate(&FXVZfilterPeak[i][v], osMult);
				tVZFilterBell_setFreqFast(&FXVZfilterPeak[i][v], FXVZfilterPeak[i][v]->cutoffMIDI);
				tVZFilterLS_setSampleRate(&FXVZfilterLS[i][v], osMult);
				tVZFilterLS_setFreqFast(&FXVZfilterLS[i][v], FXVZfilterLS[i][v]->cutoffMIDI);
				tVZFilterHS_setSampleRate(&FXVZfilterHS[i][v], osMult);
				tVZFilterHS_setFreqFast(&FXVZfilterHS[i][v], FXVZfilterHS[i][v]->cutoffMIDI);
				tVZFilter_setSampleRate(&FXVZfilterBR[i][v], osMult);
				tVZFilter_setFreq(&FXVZfilterBR[i][v], FXVZfilterBR[i][v]->fc);
				tLadderFilter_setSampleRate(&FXLadderfilter[i][v], osMult);
				tLadderFilter_setFreqFast(&FXLadderfilter[i][v], FXLadderfilter[i][v]->cutoffMIDI);
			}
		}
	}
	prevOversample = newOS;
}



float FORCE_INLINE pickupNonLinearity(float x)
{
	x = x * 2.0f; //initial scaling to match mm of displacement
	float out = (0.075f * x) + (0.00675f * x * x) +( 0.00211f * x * x * x) + (0.000475f * x * x * x * x) + (0.000831f * x * x * x * x *x);
	return out * 4.366812227074236f; //output scaling to bring +/-0.229 to +/-1.0
}

float FORCE_INLINE mtofTableLookup(float tempMIDI)
{
	float tempIndexF = ((LEAF_clip(-163.0f, tempMIDI, 163.0f) * 100.0f) + 16384.0f);
	int tempIndexI = (int)tempIndexF;
	tempIndexF = tempIndexF -tempIndexI;
	float freqToSmooth1 = mtofTable[tempIndexI & 32767];
	float freqToSmooth2 = mtofTable[(tempIndexI + 1) & 32767];
	return ((freqToSmooth1 * (1.0f - tempIndexF)) + (freqToSmooth2 * tempIndexF));
}


void audioInit()
{
	// Initialize LEAF.

	LEAF_init(&leaf, SAMPLE_RATE, small_memory, SMALL_MEM_SIZE, &randomNumber);

	tMempool_init (&mediumPool, medium_memory, MED_MEM_SIZE, &leaf);
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE, &leaf);

	leaf.clearOnAllocation = 1;
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
	decayExpBufferSizeMinusOne = DECAY_EXP_BUFFER_SIZE - 1;
	invNumOvertones = 1.0f / NUM_OVERTONES;
	for (int i = 0; i < 12; i++)
	{
		previousStringInputs[i]	= 0;
	}
	tCycle_init(&testSine, &leaf);
	tCycle_setFreq(&testSine, 440.0f);

	for (int i = 0; i < NUM_OVERTONES; i++)
	{
		totalGain[0] += partials[i];
		totalGain[1] += partialsHigh[i];

		for (int j = 0; j < 3; j++)

		{
			for (int k = 0; k < 3; k++)
			{
				totalGain_s[j][k] += stringPartialGains[j][k][i];
			}
		}

	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			gainNormalizers_s[i][j] = 1.0f / totalGain_s[i][j];
		}
	}
	gainNormalizers[0] = 1.0f / totalGain[0];
	gainNormalizers[1] = 1.0f / totalGain[1];
	for (int i = 0; i < NUM_OVERTONES; i++)
	{
		partials[i] = partials[i] * gainNormalizers[0];
		partialsHigh[i] = partialsHigh[i] * gainNormalizers[1];


		for (int j = 0; j < 3; j++)

		{
			for (int k = 0; k < 3; k++)
			{
				stringPartialGains[j][k][i] *= gainNormalizers_s[j][k];
			}
		}

	}

	for (int i = 0; i < NUM_OVERTONES; i++)
	{
		  decayAfParts[i] = (((1.0f/partialDecaysHigh[i])-(1.0f/partialDecays[i])) * 0.004048582995951f);  // divided by 370-123 = 247. value is 1/247

		  decayAf1[i] = decayAfParts[i] * 123.0f;

		  decayBs[i] = (1.0f/partialDecays[i]) - decayAf1[i];

		  for (int j = 0; j < 3; j++)
		  {

			  for (int k = 0; k < 2; k++)
			  {
				  float tempDivisor = (stringFundamentals[j][k+1] -  stringFundamentals[j][k]);
				  dAp[j][k][i] = ((1.0f / stringDecays[j][k+1][i]) - (1.0f / stringDecays[j][k][i])) / tempDivisor;

				  dAi[j][k][i] = dAp[j][k][i] * stringFundamentals[j][k];

				  dBs[j][k][i] = (1.0f/stringDecays[j][k][i]) - dAi[j][k][i];
			  }
		  }

	}

	for (int i = 0; i < 256; i++)
	{
		randomFactors[i] = (randomNumber() * 0.4f) + 0.8f;
	}
	LEAF_generate_atodb(atoDbTable, ATODB_TABLE_SIZE, 0.00001f, 1.0f);
	LEAF_generate_dbtoa(dbtoATable, DBTOA_TABLE_SIZE, -90.0f, 50.0f);

	atodbTableScalar = ATODB_TABLE_SIZE_MINUS_ONE/(1.0f-0.00001f);
	atodbTableOffset = 0.00001f * atodbTableScalar;
	dbtoaTableScalar = DBTOA_TABLE_SIZE_MINUS_ONE/(50.0f+90.0f);
	dbtoaTableOffset = -90.0f * dbtoaTableScalar;

	LEAF_generate_mtof(mtofTable, -163.8375f, 163.8375f,  MTOF_TABLE_SIZE); //mtof table for fast calc





	if (numStrings == 6)
	{
		firstString = boardNumber;
		numStringsThisBoard = 1;
	}

	else if (numStrings == 10)
	{
		// first two strings are one board each, other 8 are two strings each.
		if (boardNumber == 0)
		{
			firstString = 0;
			numStringsThisBoard = 1;
		}
		else if (boardNumber == 1)
		{
			firstString = 1;
			numStringsThisBoard = 1;
		}
		else
		{
			firstString = (boardNumber - 1) * NUM_STRINGS_PER_BOARD;
			numStringsThisBoard = 2;
		}
	}

	else //otherwise 12-string version
	{

		firstString = boardNumber * NUM_STRINGS_PER_BOARD;
		numStringsThisBoard = 2;

	}

	for (int i = 0; i < numStringsThisBoard; i++)
	{

		for (int j = 0; j < NUM_OVERTONES; j++)
		{
			tCycle_init(&additive[i][j], &leaf);
			tADSRT_init(&additiveEnv[i][j], 5.0f, partialDecays[j] * 1000.0f, 0.0f, 150.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);
		}
		//tExpSmooth_init(&stringFreqSmoothers[i],1.0f, 0.05f, &leaf);

	}



	tExpSmooth_init(&volumeSmoother,0.0f, 0.0005f, &leaf);
	for (int i = 0; i < 12; i++)
	{
		tExpSmooth_init(&knobSmoothers[i],0.0f, 0.0005f, &leaf);
	}
	for (int i = 0; i < 10; i++)
	{
		tExpSmooth_init(&pedalSmoothers[i],0.0f, 0.0005f, &leaf);
	}
	tExpSmooth_init(&barNoiseSmoother,0.0f, 0.002f, &leaf);

	for (int v = 0; v < numStringsThisBoard; v++)
	{

		for(int i = 0; i < NUM_OSC; i++)
		{
			tPBSaw_init(&saw[i][v], &leaf);

			tPBPulse_init(&pulse[i][v], &leaf);

			tCycle_init(&sine[i][v],  &leaf);

			tPBTriangle_init(&tri[i][v],  &leaf);

			tPBSawSquare_init(&sawPaired[i][v], &leaf);

			tPBSineTriangle_init(&sinePaired[i][v],&leaf);

			tExpSmooth_init(&pitchSmoother[i][v], 64.0f, 0.005f, &leaf);

			freqMult[i][v] = 1.0f;
			midiAdd[i][v] = 0.0f;

		}
		tSimpleLivingString3_initToPool(&livStr[v], 4, 220.0f, 17000.0f,
					                                 0.99999f, 0.0f, 0.01f,
					                                 0.01f, 0, &mediumPool);

		tSimpleLivingString3_setTargetLev(&livStr[v], 0.047059f);
		tSimpleLivingString3_setLevSmoothFactor(&livStr[v], 0.0301913f);
		tSimpleLivingString3_setLevStrength(&livStr[v], 0.0f);
		tSimpleLivingString3_setLevMode(&livStr[v], 1);

		whichStringModelLoaded = String1Loaded;
/*
		tSimpleLivingString5_initToPool(&strings[v], 100.0f, 0.6f, 0.3f, .9f, 0.0f, .9999f, .9999f, 0.0f, 0.05f, 0.05f, 1, &largePool);
		tSimpleLivingString5_setBrightness(&strings[v], .99f);
		tSimpleLivingString5_setPickPos(&strings[v], .5f);
		tSimpleLivingString5_setPrepPos(&strings[v], .4f);
		tSimpleLivingString5_setPrepIndex(&strings[v], 0.0f);
		tSimpleLivingString5_setPickupPos(&strings[v], 1.0f);
*/
		tADSRT_init(&fenvelopes[v], 0.0f,  50.0f, 0.0f, 200.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);


		tVZFilter_init(&noiseFilt, BandpassPeak, 1500.0f, 1.5f, &leaf);
		tVZFilter_init(&noiseFilt2, Lowpass, 800.0f, 0.9f, &leaf);
		tVZFilter_setFreq(&noiseFilt2, 3332.0f); //based on testing with knob values
		tNoise_init(&myNoise, WhiteNoise, &leaf);
		for (int i = 0; i < NUM_FILT; i++)
		{
			tSVF_init(&lowpass[i][v], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
			tSVF_init(&highpass[i][v], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
			tSVF_init(&bandpass[i][v], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
			tDiodeFilter_init(&diodeFilters[i][v], 2000.f, 0.5f, &leaf);
			tVZFilterBell_init(&VZfilterPeak[i][v], 2000.f, 1.9f, 1.0f, &leaf);
			tVZFilterLS_init(&VZfilterLS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterHS_init(&VZfilterHS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilter_init(&VZfilterBR[i][v], BandReject, 2000.f, 1.0f, &leaf);
			tLadderFilter_init(&Ladderfilter[i][v], 2000.f, 1.0f, &leaf);
			tExpSmooth_init(&filterCutoffSmoother[i][v], 64.0f, 0.01f, &leaf);
		}

		for (int i = 0; i < NUM_LFOS; i++)
		{
			tIntPhasor_init(&lfoSaw[i][v], &leaf);
			tSquareLFO_init(&lfoPulse[i][v], &leaf);
			tCycle_init(&lfoSine[i][v], &leaf);
			tTriLFO_init(&lfoTri[i][v], &leaf);

			tSineTriLFO_init(&lfoSineTri[i][v], &leaf);
			tSawSquareLFO_init(&lfoSawSquare[i][v], &leaf);
		}
		//noise
		tVZFilterLS_init(&noiseShelf1[v], 80.0f, 0.5f, 1.0f, &leaf);
		tVZFilterHS_init(&noiseShelf2[v], 12000.0f, 0.5f, 1.0f, &leaf);
		tVZFilterBell_init(&noiseBell1[v],1000.0f, 1.9f, 1.09f, &leaf);


		for (int i = 0; i < NUM_ENV; i++)
		{
			tADSRT_init(&envs[i][v], 0.1f,1000.f,0.5f,1.0f,decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);
			tADSRT_setLeakFactor(&envs[i][v], ((1.0f - 0.1f) * 0.00005f) + 0.99995f);
		}


		for (int i = 0; i < NUM_EFFECT; i++)
		{
			tCrusher_init(&bc[i][v],&leaf);
			tHighpass_init(&dcBlock1[i][v], 5.0f,&leaf);
			tHighpass_setSampleRate(&dcBlock1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tHighpass_init(&dcBlock2[i][v], 5.0f,&leaf);
			tHighpass_setSampleRate(&dcBlock2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterLS_init(&shelf1[i][v], 80.0f, 0.5f, 1.0f,&leaf);
			tVZFilterLS_setSampleRate(&shelf1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterHS_init(&shelf2[i][v], 12000.0f, 0.5f, 1.0f, &leaf);
			tVZFilterHS_setSampleRate(&shelf2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterBell_init(&bell1[i][v], 1000.0f, 1.9f, 1.0f, &leaf);
			tVZFilterBell_setSampleRate(&bell1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCompressor_init(&comp[i][v], &leaf);
			tCompressor_setTables(&comp[i][v], atoDbTable, dbtoATable, 0.00001f, 4.0f, -90.0f, 30.0f, ATODB_TABLE_SIZE, DBTOA_TABLE_SIZE);
			tCompressor_setSampleRate(&comp[i][v], SAMPLE_RATE * OVERSAMPLE);
			tLinearDelay_initToPool(&delay1[i][v], 4000.0f, 4096, &largePool);
			tLinearDelay_initToPool(&delay2[i][v], 4000.0f, 4096, &largePool);
			tCycle_init(&mod1[i][v], &leaf);
			tCycle_setSampleRate(&mod1[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCycle_init(&mod2[i][v], &leaf);
			tCycle_setSampleRate(&mod2[i][v], SAMPLE_RATE * OVERSAMPLE);
			tCycle_setFreq(&mod1[i][v], 0.2f);
			tCycle_setFreq(&mod2[i][v], 0.22222222222f);

	        tTapeDelay_initToPool(&tapeDelay[i][v], 15000.0f, 30000, &largePool);
	        tFeedbackLeveler_init(&feedbackControl[i][v], .99f, 0.01f, 0.125f, 0, &leaf);

			//filters
			tSVF_init(&FXlowpass[i][v], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXlowpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tSVF_init(&FXhighpass[i][v], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXhighpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tSVF_init(&FXbandpass[i][v], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
			tSVF_setSampleRate(&FXbandpass[i][v],SAMPLE_RATE * OVERSAMPLE);
			tDiodeFilter_init(&FXdiodeFilters[i][v], 2000.f, 1.0f, &leaf);
			tDiodeFilter_setSampleRate(&FXdiodeFilters[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterBell_init(&FXVZfilterPeak[i][v], 2000.f, 1.6f, 1.0f, &leaf);
			tVZFilterBell_setSampleRate(&FXVZfilterPeak[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterLS_init(&FXVZfilterLS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterLS_setSampleRate(&FXVZfilterLS[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilterHS_init(&FXVZfilterHS[i][v], 2000.f, 0.6f, 1.0f, &leaf);
			tVZFilterHS_setSampleRate(&FXVZfilterHS[i][v], SAMPLE_RATE * OVERSAMPLE);
			tVZFilter_init(&FXVZfilterBR[i][v], BandReject, 2000.f, 1.0f, &leaf);
			tVZFilter_setSampleRate(&FXVZfilterBR[i][v], SAMPLE_RATE * OVERSAMPLE);
			tLadderFilter_init(&FXLadderfilter[i][v], 2000.f, 1.0f, &leaf);
			tLadderFilter_setSampleRate(&FXLadderfilter[i][v], SAMPLE_RATE * OVERSAMPLE);
		}

		for (int i = 0; i < MAX_NUM_MAPPINGS; i++)
		{
			tExpSmooth_init(&mapSmoothers[i][v], 0.0f, 0.005f, &leaf);
		}

		tVoc_init(&vocal[v], &leaf);
		arm_fir_interpolate_init_f32(&osI[v],2,32,__leaf_table_fir2XLow, intState[v],1);
		arm_fir_decimate_init_f32(&osD[v],32, 2,__leaf_table_fir2XLow, decState[v],2);

		tSVF_init(&finalLowpass[v], SVFTypeLowpass, 19000.f, 0.3f, &leaf);
	}

	for (int i = 0; i < AUDIO_BUFFER_SIZE; i++)
	{

			audioOutBuffer[ i] = (int32_t)(0.0f * TWO_TO_23);
	}

	audioFrameFunction = audioFrameSynth;
	HAL_Delay(1);

}

void audioStart(SAI_HandleTypeDef* hsaiOut, SAI_HandleTypeDef* hsaiIn)
{
	HAL_Delay(1);
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
}


void __ATTR_ITCMRAM updateStateFromSPIMessage(uint8_t offset)
{
	int modeBit = SPI_LEVERS_RX[24 + offset];

	octaveAction = (modeBit >> 6) & 1;
	dualSlider = (modeBit >> 5) & 1;

	edit = (modeBit >> 4) & 1;
	voice = SPI_LEVERS_RX[25 + offset];



	octave = (((int32_t) (modeBit & 15) - 5 ) * 12.0f);
	//if "octave action" is set to 1, then immediately change octave instead of waiting for new note
	if (octaveAction)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			stringOctave[i] = octave;
		}
	}

	volumePedalInt = ((uint16_t)SPI_LEVERS_RX[26 + offset] << 8) + ((uint16_t)SPI_LEVERS_RX[27 + offset] & 0xff);
	volumePedal = volumePedalInt * 0.0002442002442f;

	stringPositions[whichBar] = ((uint16_t)SPI_LEVERS_RX[28 + offset] << 8) + ((uint16_t)SPI_LEVERS_RX[29 + offset] & 0xff);
	if (stringPositions[whichBar] != stringPositionsPrev[whichBar])
	{
		//HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_SET);
		stringPositionsPrev[whichBar] = stringPositions[whichBar];
		barInMIDI[0] = stringPositions[0] * 0.001953125f;
		barInMIDI[1] = stringPositions[1] * 0.001953125f;
	}
	tExpSmooth_setDest(&volumeSmoother,volumePedal);
}




void __ATTR_ITCMRAM switchStringModel(int which)
{
	if (which == 1)
	{
		if (whichStringModelLoaded != String1Loaded)
		{
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				tSimpleLivingString5_free(&strings[v]);
			}
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				tSimpleLivingString3_initToPool(&livStr[v], 4, 220.0f, 17000.0f,
															 0.99999f, 0.0f, 0.01f,
														 0.01f, 0, &mediumPool);
				tSimpleLivingString3_setTargetLev(&livStr[v], 0.047059f);
				tSimpleLivingString3_setLevSmoothFactor(&livStr[v], 0.0301913f);
				tSimpleLivingString3_setLevStrength(&livStr[v], 0.0f);
				tSimpleLivingString3_setLevMode(&livStr[v], 1);

			}
		}
		//load string1 default params:
		for (int i = 0; i < 12; i++)
		{
			tExpSmooth_setValAndDest(&knobSmoothers[i], string1Defaults[i]);
			knobFrozen[i] = 1;
		}
		tVZFilter_setFreq(&noiseFilt2, 3332.0f); //based on testing with knob values
		whichStringModelLoaded = String1Loaded;
		audioFrameFunction = audioFrameString1;
	}


	else if (which == 2)
	{
		if (whichStringModelLoaded != String2Loaded)
		{
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				tSimpleLivingString3_free(&livStr[v]);
			}
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				tSimpleLivingString5_initToPool(&strings[v], 2, 440.0f, 18000.0f, .99999f, 0.75f, 0.0f, .666f, 0.3f, 0.05f, 0.05f, 0, &mediumPool);

				//tSimpleLivingString5_setBrightness(&strings[v], .99f);
				tSimpleLivingString5_setPluckPosition(&strings[v], .5f);
				tSimpleLivingString5_setPrepPosition(&strings[v], .4f);
				tSimpleLivingString5_setPrepIndex(&strings[v], 0.0f);
				tSimpleLivingString5_setPickupPoint(&strings[v], 1.0f);
			}
		}
		//load string2 default params:
		for (int i = 0; i < 12; i++)
		{
			tExpSmooth_setValAndDest(&knobSmoothers[i], string2Defaults[i]);
			knobFrozen[i] = 1;
		}
		whichStringModelLoaded = String2Loaded;
		audioFrameFunction = audioFrameString2;
	}
	presetReady = 1;
	diskBusy = 0;
	currentActivePreset = voice;

}

void __ATTR_ITCMRAM audioFrameSynth(uint16_t buffer_offset)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;

	if (resetStringInputs)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			//note off
			for (int v = 0; v < NUM_ENV; v++)
			{
				tADSRT_clear(&envs[v][i]);
				previousStringInputs[i] = 0;
			}
		}
		resetStringInputs = 0;
	}
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;
				stringOctave[i] = octave;
				//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);

				for (int v = 0; v < NUM_ENV; v++)
				{
					if (envOn[v])
					{
						param* envParams = &params[ENVELOPE_PARAMS_OFFSET + v * EnvelopeParamsNum];
						float useVelocity = envParams[EnvelopeVelocity].realVal[i];
						float envVel = amplitz;
						if (useVelocity == 0) envVel = 1.f;
						tADSRT_on(&envs[v][i], envVel);
						voiceSounding = 1;
					}
				}
				for (int v = 0; v < NUM_LFOS; v++)
				{
					if (lfoOn[v])
					{
						param* lfoParams = &params[LFO_PARAMS_OFFSET + v * LFOParamsNum];
						float noteOnSync = lfoParams[LFOSync].realVal[i];
						if (noteOnSync > 0.5f)
						{
							lfoParams[LFOPhase].setParam(lfoParams[LFOPhase].realVal[i], v, i);
						}
					}
				}
				//sample and hold noise
				sourceValues[RANDOM_SOURCE_OFFSET][i] = (random_values[randomValPointer++] * 0.5f) + 0.5f; // scale between zero and one
				sourceValues[VELOCITY_SOURCE_OFFSET][i] = amplitz;

			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				for (int v = 0; v < NUM_ENV; v++)
				{
					if (envOn[v])
					{
						tADSRT_off(&envs[v][i]);
					}
				}
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}
	//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		current_sample = (int32_t)(audioTickSynth() * TWO_TO_23);
		audioOutBuffer[buffer_offset + i] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;
	}



	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;

	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;
	if (frameLoadPercentage > .99f)
	{
		frameLoadOverCount++;
		if (frameLoadOverCount > 3)
		{

			if (overSampled == 1)
			{
				overSampled = 0;
				changeOversampling(overSampled);
			}
			else if (oscToTick > 0)
			{
				oscToTick--;
			}
		}
	}
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
}

void __ATTR_ITCMRAM audioFrameString1(uint16_t buffer_offset)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;

	if (resetStringInputs)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			//note off
			lsDecay[i] = 0;
			previousStringInputs[i] = 0;
		}
		resetStringInputs = 0;
	}
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;
				stringOctave[i] = octave;
				//then it's the string synth
				//tSimpleLivingString3_setDecay(&livStr[i], 20.0f);
				tSimpleLivingString3_pluck(&livStr[i], amplitz, LEAF_clip(0.0f, ((pluckPos * randomFactors[currentRandom]) * knobScaled[2]) + (pluckPos * (1.0f - knobScaled[2])),1.0f));
				currentRandom++;
				lsDecay[i] = 1;

			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				//tSimpleLivingString3_setDecay(&livStr[i], 0.1f);
				lsDecay[i] = 0;
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}
	//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		int iplusbuffer = buffer_offset + i;
		int iplusone = iplusbuffer+1;
		audioInputs[0] = ((float) (((int32_t)(audioInBuffer[iplusbuffer]<<8)))) * INV_TWO_TO_31;
		audioInputs[1] = ((float) (((int32_t)(audioInBuffer[iplusone]<<8)))) * INV_TWO_TO_31;
		current_sample = (int32_t)(audioTickString1() * TWO_TO_23);
		audioOutBuffer[iplusbuffer] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;
	}

	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;

}

void __ATTR_ITCMRAM audioFrameString2(uint16_t buffer_offset)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;

	if (resetStringInputs)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			//note off
			tSimpleLivingString5_setTargetLev(&strings[i], 0.0f);
			tSimpleLivingString5_setLevMode(&strings[i], 0);
			tSimpleLivingString5_setDecay(&strings[i], 0.2f);
			tADSRT_off(&fenvelopes[i]);
			previousStringInputs[i] = 0;
		}
		resetStringInputs = 0;
	}

	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;

				stringOctave[i] = octave;
				tADSRT_on(&fenvelopes[i], amplitz);

				tSimpleLivingString5_setLevMode(&strings[i], (knobScaled[0] > 0.5f));

				tSimpleLivingString5_setTargetLev(&strings[i], knobScaled[1]);
				tSimpleLivingString5_pluck(&strings[i], amplitz, knobScaled[2]);
				tSimpleLivingString5_setDecay(&strings[i], knobScaled[3] * .2f + 0.9f);
			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				tSimpleLivingString5_setTargetLev(&strings[i], 0.0f);
				tSimpleLivingString5_setLevMode(&strings[i], 0);
				tSimpleLivingString5_setDecay(&strings[i], 0.2f);

				tADSRT_off(&fenvelopes[i]);
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}

	//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		int iplusbuffer = buffer_offset + i;
		int iplusone = iplusbuffer+1;
		audioInputs[0] = ((float) (((int32_t)(audioInBuffer[iplusbuffer]<<8)))) * INV_TWO_TO_31;
		audioInputs[1] = ((float) (((int32_t)(audioInBuffer[iplusone]<<8)))) * INV_TWO_TO_31;

		current_sample = (int32_t)(audioTickString2() * TWO_TO_23);
		audioOutBuffer[buffer_offset + i] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;

	}


	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;
	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);

}

void __ATTR_ITCMRAM audioFrameAdditive(uint16_t buffer_offset)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;

				stringOctave[i] = octave;
				//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);

				tADSRT_on(&fenvelopes[i], amplitz);
				stringFrequencies[i] = mtof(stringMIDIPitches[i]+ stringOctave[i]);
				//float thisDecay = 1.0f / ((decayAfParts[j] * stringFrequencies[i]) + decayBs[j]);
				float thisDecay;
				//float thisGain = map(LEAF_clip(132.0f, stringFrequencies[i], 370.0f), 123.0f, 370.0f, partials[j], partialsHigh[j]);
				float d1;
				float d2;
				float thisGain;
				int thisString = i + firstString;
				float stringFade;
				float fakedFreq = stringFrequencies[i] * ((knobScaled[2] * 3.5f) + 0.5f);
				float height2 = 0.0f;
				float height1 = 0.0f;
				if (thisString < 6)
				{
					stringFade = (float)thisString * 0.2f;
					height2 = LEAF_clip(0.0f, LEAF_map(fakedFreq, stringFundamentals[2][0], stringFundamentals[2][2], 0.0f, 2.0f), 1.99f);
					height1 = LEAF_clip(0.0f, LEAF_map(fakedFreq, stringFundamentals[1][0], stringFundamentals[1][2], 0.0f, 2.0f), 1.99f);
				}
				else
				{
					stringFade = (float)(thisString - 6.0f) * 0.2f;
					height2 = LEAF_clip(0.0f, LEAF_map(fakedFreq, stringFundamentals[1][0], stringFundamentals[1][2], 0.0f, 2.0f), 1.99f);
					height1 = LEAF_clip(0.0f, LEAF_map(fakedFreq, stringFundamentals[0][0], stringFundamentals[0][2], 0.0f, 2.0f), 1.99f);
				}
				//float fakedFreq = stringFrequencies[i];
				//float height2 = LEAF_clip(0.0f,(barInMIDI[0] *  0.083333333333333f) + stringOctave[i] + (knobScaled[2] * 2.0f), 1.99f);
				//float height1 = height2;
				int height1Int = floor(height1);
				float height1Float = height1 - height1Int;
				int height2Int = floor(height2);
				float height2Float = height2 - height2Int;
				for (int j = 0; j < NUM_OVERTONES; j++)
				{
					if (thisString < 6)
					{
						float x1 =  (stringPartialGains[1][height1Int][j] * (1.0f - height1Float)) + (stringPartialGains[1][height1Int + 1][j] * height1Float);
						float x2 =  (stringPartialGains[2][height2Int][j] * (1.0f - height2Float)) + (stringPartialGains[2][height2Int + 1][j] * height2Float);
						thisGain = (x1 * stringFade) + (x2 * (1.0f - stringFade));


						if (height2 < 1.0f)
						{
							d2 = 1.0f / ((dAp[2][0][j] * LEAF_clip(stringFundamentals[2][0], fakedFreq, stringFundamentals[2][1])) + dBs[2][0][j]);
						}
						else
						{
							d2 = 1.0f / ((dAp[2][1][j] * LEAF_clip(stringFundamentals[2][1], fakedFreq, stringFundamentals[2][2])) + dBs[2][1][j]);
						}

						if (height1 < 1.0f)
						{
							d1 = 1.0f / ((dAp[1][0][j] * LEAF_clip(stringFundamentals[1][0], fakedFreq, stringFundamentals[1][1])) + dBs[1][0][j]);
						}
						else
						{
							d1 = 1.0f / ((dAp[1][1][j] * LEAF_clip(stringFundamentals[1][1], fakedFreq, stringFundamentals[1][2])) + dBs[1][1][j]);
						}

						thisDecay = (d1 * stringFade) + (d2 * (1.0f - stringFade));
					}
					else
					{


						float x1 =  stringPartialGains[0][height1Int][j] + (stringPartialGains[1][height1Int + 1][j] * height1Float);
						float x2 =  stringPartialGains[1][height2Int][j] + (stringPartialGains[2][height2Int + 1][j] * height2Float);
						thisGain = (x1 * stringFade) + (x2 * (1.0f - stringFade));

						if (height2 < 1.0f)
						{
							d2 = 1.0f / ((dAp[1][0][j] * LEAF_clip(stringFundamentals[1][0], fakedFreq, stringFundamentals[1][1])) + dBs[1][0][j]);
						}
						else
						{
							d2 = 1.0f / ((dAp[1][1][j] * LEAF_clip(stringFundamentals[1][1], fakedFreq, stringFundamentals[1][2])) + dBs[1][1][j]);
						}

						if (height1 < 1.0f)
						{
							d1 = 1.0f / ((dAp[0][0][j] * LEAF_clip(stringFundamentals[0][0], fakedFreq, stringFundamentals[0][1])) + dBs[0][0][j]);
						}
						else
						{
							d1 = 1.0f / ((dAp[0][1][j] * LEAF_clip(stringFundamentals[0][1], fakedFreq, stringFundamentals[0][2])) + dBs[0][1][j]);
						}

						thisDecay = (d1 * stringFade) + (d2 * (1.0f - stringFade));
					}
					thisDecay *= 2000.0f * knobScaled[3];
					tADSRT_setDecay(&additiveEnv[i][j], thisDecay + (randomFactors[currentRandom] * knobScaled[5] * 0.1f));// * randomFactors[currentRandom]);
					currentRandom++;
					tADSRT_on(&additiveEnv[i][j], amplitz * (thisGain + (randomFactors[currentRandom] * knobScaled[6] * 0.1f)));
					currentRandom++;
				}
			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET);
				for (int j = 0; j < NUM_OVERTONES; j++)
				{
					tADSRT_off(&additiveEnv[i][j]);
				}
				tADSRT_off(&fenvelopes[i]);
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}


		//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		current_sample = (int32_t)(audioTickAdditive() * TWO_TO_23);
		audioOutBuffer[buffer_offset + i] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;
	}

	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;
	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
}

float diameters[44];

void __ATTR_ITCMRAM audioFrameVocal(uint16_t buffer_offset)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
	uint32_t tempCountFrame = DWT->CYCCNT;
	int32_t current_sample = 0;
	if (newPluck)
	{
		for (int i = 0; i < numStringsThisBoard; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{
				float amplitz = stringInputs[i] * 0.000015259021897f;

				stringOctave[i] = octave;
				//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);

				//tADSRT_on(&fenvelopes[i], amplitz);
				stringFrequencies[i] = mtof(stringMIDIPitches[i]+ stringOctave[i]);

				tADSRT_setSustain(&additiveEnv[i][0], 1.0f);// * randomFactors[currentRandom]);

				tADSRT_on(&additiveEnv[i][0], amplitz);

			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off

				tADSRT_off(&additiveEnv[i][0]);
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}

	for (int i = 0; i < 1; i++)
	{
		tVoc_set_tongue_shape_and_touch(&vocal[i], knobScaled[8], knobScaled[9],knobScaled[10],knobScaled[11]);
		tVoc_set_velum(&vocal[i], (0.4f * knobScaled[7]) + 0.01f);
	}

	for (int j = 0; j < 44; j++)
	{
		diameters[j] = vocal[0]->tr->diameter[j];
	}

		//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
	for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
	{
		current_sample = (int32_t)(audioTickVocal() * TWO_TO_23);
		audioOutBuffer[buffer_offset + i] = current_sample;
		audioOutBuffer[buffer_offset + i + 1] = current_sample;
	}

	if (switchStrings)
	{
		switchStringModel(switchStrings);
	}
	switchStrings = 0;
	timeFrame = DWT->CYCCNT - tempCountFrame;
	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
}



float __ATTR_ITCMRAM audioTickSynth(void)
{
	uint32_t tempCountTick = DWT->CYCCNT;
	float masterSample = 0.0f;

	//run mapping ticks for all strings
	uint32_t tempCountMap = DWT->CYCCNT;
	tickMappings();
	timeMap = DWT->CYCCNT - tempCountMap;

	uint32_t tempSmoothing = DWT->CYCCNT;
	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			sourceValues[MACRO_SOURCE_OFFSET + i][v] = knobScaled[i];
		}
	}
	for (int i = 0; i < 10; i++)
	{
		pedalScaled[i] = tExpSmooth_tick(&pedalSmoothers[i]);
		for (int v = 0; v < numStringsThisBoard; v++)
		{
			sourceValues[PEDAL_SOURCE_OFFSET + i][v] = pedalScaled[i];
		}
	}
	for (int v = 0; v < numStringsThisBoard; v++)
	{
		sourceValues[EXPRESSION_PEDAL_SOURCE_OFFSET][v] = volumePedal;
	}
	timeSmoothing = DWT->CYCCNT - tempSmoothing;

	float note[numStringsThisBoard];
	uint32_t tempPerStringTick = DWT->CYCCNT;
	for (int v = 0; v < numStringsThisBoard; v++)
	{
		float sample = 0.0f;

		uint32_t tempCountGettingNote = DWT->CYCCNT;
		note[v] = stringMIDIPitches[v] + stringOctave[v];
		sourceValues[MIDI_KEY_SOURCE_OFFSET][v] = (note[v] - midiKeySubtractor) * midiKeyDivisor;

		if (note[v] < 0.0f)
		{
			note[v] = 0.0f;
		}
		if (note[v] > 127.0f)
		{
			note[v] = 127.0f;
		}
		if (isnan(note[v]))
		{
			note[v] = 64.0f;
		}
		timeGettingNote = DWT->CYCCNT - tempCountGettingNote;

		uint32_t tempCountEnv = DWT->CYCCNT;
		envelope_tick(v);
		timeEnv = DWT->CYCCNT - tempCountEnv;

		uint32_t tempCountLFO = DWT->CYCCNT;
		lfo_tick(v);
		timeLFO = DWT->CYCCNT - tempCountLFO;

		uint32_t tempCountOsc = DWT->CYCCNT;
		oscillator_tick(note[v], v);
		timeOsc = DWT->CYCCNT - tempCountOsc;

		uint32_t tempCountNoise = DWT->CYCCNT;
		if (noiseOn)
		{
			noise_tick(v);
		}
		timeNoise = DWT->CYCCNT - tempCountNoise;

		float filterSamps[2] = {0.0f, 0.0f};
		for (int i = 0; i < oscToTick; i++)
		{
			filterSamps[0] += oscOuts[0][i][v];
			filterSamps[1] += oscOuts[1][i][v];
		}
		filterSamps[0] += noiseOuts[0][v];
		filterSamps[1] += noiseOuts[1][v];

		uint32_t tempCountFilt = DWT->CYCCNT;
		sample = filter_tick(&filterSamps[0], note[v], v);
		timeFilt = DWT->CYCCNT - tempCountFilt;

		if (fxPre)
		{
			sample *= amplitude[v];
		}
		uint32_t tempCountOS = DWT->CYCCNT;

		if (overSampled)
		{

			//oversample for non-linear effects (distortion, etc)
			//using the arm interpolation and decimation cuts 100 cycles off of the processing
			arm_fir_interpolate_f32(&osI[v], &sample, (float*)&oversamplerArray, 1);


			for (int i = 0; i < 4; i++)
			{
				if (effectsActive[i])
				{
					for (int j = 0; j < OVERSAMPLE; j++)
					{
						float dry = oversamplerArray[j]; //store the dry value to mix later
						oversamplerArray[j] = effectTick[i](oversamplerArray[j], i, v); //run the effect
						oversamplerArray[j] = ((1.0f - fxMix[i][v]) * dry) + (fxMix[i][v] * oversamplerArray[j]); //mix in dry/wet at the "mix" amount
						oversamplerArray[j] *= fxPostGain[i][v]; //apply postgain
					}
				}
			}
			//downsample to get back to normal sample rate
			arm_fir_decimate_f32(&osD[v], (float*)&oversamplerArray, &sample, 2);
		}
		else
		{
			for (int i = 0; i < NUM_EFFECT; i++)
			{
				if (effectsActive[i])
				{
					float dry = sample;
					sample = effectTick[i](sample, i, v); //run the effect
					sample =((1.0f - fxMix[i][v]) * dry) + (fxMix[i][v] * sample);
					sample *= fxPostGain[i][v];
				}
			}
		}

		timeOS = DWT->CYCCNT - tempCountOS;

		if (!fxPre)
		{
			sample *= amplitude[v];
		}

		sample = tSVF_tick(&finalLowpass[v], sample) * masterVolFromBrainForSynth;
		masterSample += sample;// * finalMaster[v];
	}
	timePerStringTick = DWT->CYCCNT - tempPerStringTick;

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;

	if (pedalControlsMaster)
	{
		masterSample *= outVol;
	}
	if (masterSample  > .999999f)
	{
		masterSample  = .999999f;
		sampleClippedCountdown = 65535;
	}
	else if (masterSample < -.999999f)
	{
		masterSample = -.9999999f;
		sampleClippedCountdown = 65535;
	}
	else
	{
		if (sampleClippedCountdown > 0)
		{
			sampleClippedCountdown--;
		}
	}
	timeTick = DWT->CYCCNT - tempCountTick;

	return masterSample * audioMasterLevel * 0.98f;
}

float __ATTR_ITCMRAM audioTickString1(void)
{
	float temp = 0.0f;
	float note[numStringsThisBoard];

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}
	pluckPos = knobScaled[9];

	for (int i = 0; i < numStringsThisBoard; i++)
	{
		note[i] = stringMIDIPitches[i] + stringOctave[i];
		//sourceValues[MIDI_KEY_SOURCE_OFFSET][v] = (note[v] - midiKeySubtractor) * midiKeyDivisor;

		if (note[i] < 0.0f)
		{
			note[i] = 0.0f;
		}
		if (note[i] > 127.0f)
		{
			note[i] = 127.0f;
		}
		if (isnan(note[i]))
		{
			note[i] = 64.0f;
		}

		//float finalFreq = mtof(note[i]);
		float dampFreq = 15778.3f;
		float decay = 0.1f;
		if (lsDecay[i])
		{
			decay = (knobScaled[10] * 800.0f) + 10.0f;
		}
		tSimpleLivingString3_setPickupPoint(&livStr[i], knobScaled[8]);
		tSimpleLivingString3_setDecay(&livStr[i], decay);
		tSimpleLivingString3_setDampFreq(&livStr[i], dampFreq);
		tSimpleLivingString3_setLevStrength(&livStr[i], knobScaled[0] * 0.0352872f);

		livStr[i]->rippleGain = knobScaled[5] * -0.03f;
		livStr[i]->rippleDelay = knobScaled[11];
		tExpSmooth_setDest(&pitchSmoother[0][i], mtof(note[i]));
		float finalFreq = tExpSmooth_tick(&pitchSmoother[0][i]);
		tSimpleLivingString3_setFreq(&livStr[i], finalFreq);
		float barDelta = fabsf(barInMIDI[0]-prevBarInMIDI[0]);
		if (barDelta > 0.5f)
		{
			barDelta = 0.0f; //to avoid noise on open string glitches
		}
		tExpSmooth_setDest(&barNoiseSmoother, barDelta);
		barDelta = tExpSmooth_tick(&barNoiseSmoother);
		prevBarInMIDI[0] = barInMIDI[0];
		//tVZFilter_setFreq(&noiseFilt, faster_mtof(knobScaled[5] * 128.0f));

		float filtNoise = tVZFilter_tickEfficient(&noiseFilt2, tNoise_tick(&myNoise));
		//filtNoise = tVZFilter_tickEfficient(&noiseFilt2, filtNoise);
		float slideNoise = filtNoise * barDelta * knobScaled[1] * 10.0f;

		temp += pickupNonLinearity(tSimpleLivingString3_tick(&livStr[i], (audioInputs[i]*.9f*knobScaled[7]) + slideNoise));
	}

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	//float volIdx = LEAF_clip(0.0f, ((volumeSmoothed * 80.0f)), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;

	//temp = input;
	temp *= outVol * masterVolFromBrain;

	return temp;
}



float  __ATTR_ITCMRAM audioTickString2(void)
{
	float temp = 0.0f;
	float note[numStringsThisBoard];

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}

	for (int i = 0; i < numStringsThisBoard; i++)
	{
		note[i] = stringMIDIPitches[i] + stringOctave[i];

		if (note[i] < 0.0f)
		{
			note[i] = 0.0f;
		}
		if (note[i] > 127.0f)
		{
			note[i] = 127.0f;
		}
		if (isnan(note[i]))
		{
			note[i] = 64.0f;
		}

		//float filtNoise = tVZFilter_tickEfficient(&noiseFilt, tNoise_tick(&myNoise));
		//filtNoise += tVZFilter_tickEfficient(&noiseFilt2, tNoise_tick(&myNoise));

		float env = tADSRT_tick(&fenvelopes[i]); //noise envelope

		tSimpleLivingString5_setPickupPoint(&strings[i],knobScaled[5]);
		tSimpleLivingString5_setDampFreq(&strings[i],knobScaled[6] * 40000.0f);
		//tVZFilter_setFreq(&noiseFilt, faster_mtof(knobScaled[5] * 128.0f));
		//tVZFilter_setFreq(&noiseFilt2,faster_mtof(knobScaled[6] * 128.0f));

		tSimpleLivingString5_setFFAmount(&strings[i], knobScaled[7]);

		tSimpleLivingString5_setFBAmount(&strings[i], knobScaled[8]);
		tSimpleLivingString5_setFoldDepth(&strings[i], knobScaled[9]);

		//tSimpleLivingString5_setBrightness(&strings[i], knobScaled[9]);
		tSimpleLivingString5_setPluckPosition(&strings[i], knobScaled[2]);

		float pos1 = controls[10];
		float pos2 = controls[11];
		float alpha = v * 0.10f;
		tSimpleLivingString5_setPrepPosition(&strings[i], knobScaled[10] * alpha + knobScaled[11] * (1.0f-alpha));

		float barDelta = fabsf(barInMIDI[0]-prevBarInMIDI[0]);
		if (barDelta > 0.2f)
		{
			barDelta = 0.0f; //to avoid noise on open string glitches
		}
		tExpSmooth_setDest(&barNoiseSmoother, barDelta);
		barDelta = tExpSmooth_tick(&barNoiseSmoother);
		prevBarInMIDI[0] = barInMIDI[0];
		//tVZFilter_setFreq(&noiseFilt, faster_mtof(knobScaled[5] * 128.0f));

		float filtNoise = tVZFilter_tickEfficient(&noiseFilt2, tNoise_tick(&myNoise));
		//filtNoise = tVZFilter_tickEfficient(&noiseFilt2, filtNoise);
		float slideNoise = filtNoise * barDelta * knobScaled[1] * 20.0f;


		float finalFreq = mtofTableLookup(note[i]);

		tSimpleLivingString5_setFreq(&strings[i], finalFreq);


		if (knobScaled[4] > 0.5f)
		{
			tSimpleLivingString5_setPrepIndex(&strings[i], knobScaled[0] * env);
		}
		else
		{
			tSimpleLivingString5_setPrepIndex(&strings[i], knobScaled[0]);
		}

		temp += (tSimpleLivingString5_tick(&strings[i],audioInputs[i] + slideNoise));//(filtNoise * env)));// + (prevSamp[i] * (0.001f * knobScaled[5]))));//filtNoise * theEnv) * env);

	}

	//float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	float volIdx = LEAF_clip(0.0f, ((volumeSmoothed * 80.0f)), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;

	//temp *= outVol;
	temp *= outVol * masterVolFromBrain;

	return LEAF_clip(-1.0f, temp * 0.98f, 1.0f);
}


float __ATTR_ITCMRAM audioTickAdditive(void)
{
	float tempSamp = 0.0f;
	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}

	float filtNoise = tVZFilter_tickEfficient(&noiseFilt, tNoise_tick(&myNoise));
	filtNoise += tVZFilter_tickEfficient(&noiseFilt2, tNoise_tick(&myNoise));
	tVZFilter_setFreq(&noiseFilt, faster_mtof(knobScaled[0] * 128.0f));
	tVZFilter_setFreq(&noiseFilt2,faster_mtof(knobScaled[1] * 128.0f));

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);
	//float Env2 = 0.0f;
	for (int i = 0; i < numStringsThisBoard; i++)
	{
		float noiseEnv = tADSRT_tick(&fenvelopes[i]); //noise envelope
		tempSamp += filtNoise * noiseEnv * knobScaled[7];
		stringFrequencies[i] = mtof(stringMIDIPitches[i]+ stringOctave[i]);
		for (int j = 0; j < NUM_OVERTONES; j++)
		{

			float thisEnv = tADSRT_tickNoInterp(&additiveEnv[i][j]);
			float tempFreq = stringFrequencies[i] * (j+1) * ((knobScaled[4]* 0.003f * j) + 1.0f);// * ((Env2 * knobScaled[5])+ 1.0f);
			//float tempFreq = 0.0f;
			if (tempFreq < 18000.0f)
			{
				tCycle_setFreq(&additive[i][j], tempFreq);
				//float upRamp = (j * invNumOvertones);
				//float downRamp = 1.0f - (j * invNumOvertones);

				//float freqWeight = (upRamp * knobScaled[0]) + (downRamp * (1.0f - knobScaled[0]));
				tempSamp += tCycle_tick(&additive[i][j]) * thisEnv;// * freqWeight;
			}
		}


	}

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	//float volIdx = LEAF_clip(0.0f, ((volumeSmoothed * 80.0f)), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;
	tempSamp *= outVol;
	tempSamp *= masterVolFromBrain;
	return tempSamp;
}

float __ATTR_ITCMRAM audioTickVocal(void)
{
	float tempSamp = 0.0f;
	for (int i = 0; i < 12; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 1; i++)
	{
		tempSamp += tVoc_tick(&vocal[i]) * tADSRT_tickNoInterp(&additiveEnv[i][0]);
		stringFrequencies[i] = mtof(stringMIDIPitches[i]+ stringOctave[i]);
		tVoc_setFreq(&vocal[i], stringFrequencies[i]);
		tVoc_set_tenseness(&vocal[i], volumeSmoothed);
		//Lfloat tongue = 12.0f + (16.0f * knobScaled[0]);
		//tVoc_set_tongue_shape(&vocal[i], tongue, 2.9f * knobScaled[1] + 0.1f);

	}

	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	//float volIdx = LEAF_clip(0.0f, ((volumeSmoothed * 80.0f)), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float outVol = volumeAmps128[volIdxInt] * omAlpha;
	outVol += volumeAmps128[volIdxIntPlus] * alpha;
	tempSamp *= outVol;
	tempSamp *= masterVolFromBrain;
	return tempSamp;
}


void __ATTR_ITCMRAM oscillator_tick(float note, int string)
{
	for (int i = 0; i < NUM_OSC; i++)
	{
		oscOuts[0][i][string] = 0.0f;
		oscOuts[1][i][string] = 0.0f;
	}
	for (int osc = 0; osc < oscToTick; osc++)
	{
		if (oscOn[osc])
		{
			param* oscParams = &params[OSC_PARAMS_OFFSET + osc * OscParamsNum];

			float fine = oscParams[OscFine].realVal[string];
			float freqOffset= oscParams[OscFreq].realVal[string];
			float shape = oscParams[OscShape].realVal[string];
			float amp = oscParams[OscAmp].realVal[string];
			float filterSend = oscParams[OscFilterSend].realVal[string];
			//int sync = oscParams[OscisSync].realVal[string] > 0.5f; // probably faster than previous roundf version but haven't tested
			float freqToSmooth = (note + (fine*0.01f));
			tExpSmooth_setDest(&pitchSmoother[osc][string], freqToSmooth);

			float tempMIDI = tExpSmooth_tick(&pitchSmoother[osc][string]) + midiAdd[osc][string];


			float finalFreq = (mtofTableLookup(tempMIDI) * freqMult[osc][string]) + freqOffset;

			float sample = 0.0f;


			//shapeTick[osc](&sample, osc, finalFreq, shape, sync, string);
			shapeTick[osc](&sample, osc, finalFreq, shape, 0, string);

			sample *= amp;

			//sourceValues[OSC_SOURCE_OFFSET + osc] = sample; // the define of zero may be wasteful
			sourceValues[osc][string] = sample;

			sample *= oscAmpMult; // divide down gain if more than one oscillator is sounding (computed at preset load)

			oscOuts[0][osc][string] = sample * (filterSend) * oscParams[OscEnabled].realVal[string];
			oscOuts[1][osc][string] = sample * (1.0f - filterSend) * oscParams[OscEnabled].realVal[string];
		}
	}
}


void __ATTR_ITCMRAM  sawSquareTick(float* sample, int v, float freq, float shape, int sync, int string)
{
	tPBSawSquare_setFreq(&sawPaired[v][string], freq);
	tPBSawSquare_setShape(&sawPaired[v][string], shape);
    //if (sync)
    {
    	//tMBSawPulse_sync(&sawPaired[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);

    }
    *sample += tPBSawSquare_tick(&sawPaired[v][string]);
}

void __ATTR_ITCMRAM  sineTriTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBSineTriangle_setFreq(&sinePaired[v][string], freq);
    tPBSineTriangle_setShape(&sinePaired[v][string],shape);
   // if (sync)
   // {
   // 	tPBSineTriangle_sync(&sinePaired[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
   // }
    *sample += tPBSineTriangle_tick(&sinePaired[v][string]);
}

void __ATTR_ITCMRAM  sawTick(float* sample, int v, float freq, float shape, int sync, int string)
{
	tPBSaw_setFreq(&saw[v][string], freq);
    //if (sync)
	//{
	//	tPBSaw_sync(&saw[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBSaw_tick(&saw[v][string]);
}

void __ATTR_ITCMRAM  pulseTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBPulse_setFreq(&pulse[v][string], freq);
    tPBPulse_setWidth(&pulse[v][string], shape);
    //if (sync)
	//{
	//	tPBPulse_sync(&pulse[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBPulse_tick(&pulse[v][string]);
}

void __ATTR_ITCMRAM  sineTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tCycle_setFreq(&sine[v][string], freq);
    *sample += tCycle_tick(&sine[v][string]);
}

void __ATTR_ITCMRAM  triTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    tPBTriangle_setFreq(&tri[v][string], freq);
    tPBTriangle_setSkew(&tri[v][string], shape);
    //if (sync)
	//{
	//	tMBTriangle_sync(&tri[v][string], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]][string]);
	//}
    *sample += tPBTriangle_tick(&tri[v][string]);
}

void __ATTR_ITCMRAM  userTick(float* sample, int v, float freq, float shape, int sync, int string)
{
    //tWaveOscS_setFreq(&wave[v], freq);
    //tWaveOscS_setIndex(&wave[v], shape);
    //*sample += tWaveOscS_tick(&wave[v]);
}



float __ATTR_ITCMRAM filter_tick(float* samples, float note, int string)
{
	float cutoff[2];
	uint8_t enabledFilt[2] = {0,0};
	for (int f = 0; f < NUM_FILT; f++)
	{
		param* filtParams = &params[FILTER_PARAMS_OFFSET + f * FilterParamsNum];
		float enabled = filtParams[FilterEnabled].realVal[string];
		enabledFilt[f] = (enabled > 0.5f);
		if (!enabledFilt[f]) continue;

		float MIDIcutoff = filtParams[FilterCutoff].realVal[string];
		float keyFollow = filtParams[FilterKeyFollow].realVal[string];
		if (isnan(note))
		{
			note = 0.0f; //is this necessary?
		}

		cutoff[f] = MIDIcutoff + (note  * keyFollow);

		//smoothing may not be necessary
		//tExpSmooth_setDest(&filterCutoffSmoother[f][string], cutoff[f]);
		//cutoff[f] = tExpSmooth_tick(&filterCutoffSmoother[f][string]);
	}

	float  sp = params[FilterSeriesParallelMix].realVal[string];

	if (enabledFilt[0])
	{
		filterTick[0](&samples[0], 0, cutoff[0], string);
	}
	float sendToFilter2 = samples[0] * (1.0f - sp);
	samples[1] += sendToFilter2;
	//compute what gets sent to the second filter
	if (enabledFilt[1])
	{
		filterTick[1](&samples[1], 1, cutoff[1], string);
	}
	return samples[1] + (samples[0] * sp);
}


void __ATTR_ITCMRAM  lowpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&lowpass[v][string], cutoff);
	*sample = tSVF_tick(&lowpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  highpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&highpass[v][string], cutoff);
	*sample = tSVF_tick(&highpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  bandpassTick(float* sample, int v, float cutoff, int string)
{
	tSVF_setFreqFast(&bandpass[v][string], cutoff);
	*sample = tSVF_tick(&bandpass[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  diodeLowpassTick(float* sample, int v, float cutoff, int string)
{
	tDiodeFilter_setFreqFast(&diodeFilters[v][string], cutoff);
	*sample = tDiodeFilter_tickEfficient(&diodeFilters[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  VZpeakTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterBell_setFreq(&VZfilterPeak[v][string], cutoff);
	*sample = tVZFilterBell_tick(&VZfilterPeak[v][string], *sample);
}

void __ATTR_ITCMRAM  VZlowshelfTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterLS_setFreqFast(&VZfilterLS[v][string], cutoff);
	*sample = tVZFilterLS_tick(&VZfilterLS[v][string], *sample);
}
void __ATTR_ITCMRAM  VZhighshelfTick(float* sample, int v, float cutoff, int string)
{
	tVZFilterHS_setFreqFast(&VZfilterHS[v][string], cutoff);
	*sample = tVZFilterHS_tick(&VZfilterHS[v][string], *sample);
}
void __ATTR_ITCMRAM  VZbandrejectTick(float* sample, int v, float cutoff, int string)
{
	tVZFilter_setFreqFast(&VZfilterBR[v][string], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterBR[v][string], *sample);
    *sample *= filterGain[v][string];
}

void __ATTR_ITCMRAM  LadderLowpassTick(float* sample, int v, float cutoff, int string)
{
	tLadderFilter_setFreqFast(&Ladderfilter[v][string], cutoff);
	*sample = tLadderFilter_tick(&Ladderfilter[v][string], *sample);
    *sample *= filterGain[v][string];
}


float midiAdd[NUM_OSC][NUM_STRINGS_PER_BOARD];

void __ATTR_ITCMRAM setFreqMultPitch(float pitch, int osc, int string)
{
	pitch *= 24.0f;
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal[string] > 0.5f) ///check for value of 1 since this is a float
	{
		pitch = roundf(pitch);
	}
	midiAdd[osc][string] = pitch;
}

void __ATTR_ITCMRAM setFreqMultHarm(float harm, int osc, int string)
{
	harm *= 15.0f;
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal[string] > 0.5f) ///check for value of 1 since this is a float
	{
		harm = roundf(harm);
	}

	if (harm >= 0)
	{
		freqMult[osc][string] = (harm + 1);
	}
	else
	{
		freqMult[osc][string] = (1.0f / fabsf((harm - 1)));
	}
}




void __ATTR_ITCMRAM  lowpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&lowpass[v][string], q);
}

void __ATTR_ITCMRAM  highpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&highpass[v][string], q);
}

void __ATTR_ITCMRAM  bandpassSetQ(float q, int v, int string)
{
    tSVF_setQ(&bandpass[v][string], q);
}

void __ATTR_ITCMRAM  diodeLowpassSetQ(float q, int v, int string)
{
	tDiodeFilter_setQ(&diodeFilters[v][string], q);
}

void __ATTR_ITCMRAM  VZpeakSetQ(float q, int v, int string)
{
	tVZFilterBell_setBandwidth(&VZfilterPeak[v][string], q);
}

void __ATTR_ITCMRAM  VZlowshelfSetQ(float q, int v, int string)
{
	tVZFilterLS_setResonance(&VZfilterLS[v][string], q);
}

void __ATTR_ITCMRAM  VZhighshelfSetQ(float q, int v, int string)
{
	tVZFilterHS_setResonance(&VZfilterHS[v][string], q);
}

void __ATTR_ITCMRAM  VZbandrejectSetQ(float q, int v, int string)
{
	tVZFilter_setResonance(&VZfilterBR[v][string], q);
}

void __ATTR_ITCMRAM  LadderLowpassSetQ(float q, int v, int string)
{
	tLadderFilter_setQ(&Ladderfilter[v][string], q);
}

void __ATTR_ITCMRAM  lowpassSetGain(float gain, int v, int string)
{
    filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  highpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  bandpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  diodeLowpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  VZpeakSetGain(float gain, int v, int string)
{
	 tVZFilterBell_setGain(&VZfilterPeak[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZlowshelfSetGain(float gain, int v, int string)
{
	tVZFilterLS_setGain(&VZfilterLS[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZhighshelfSetGain(float gain, int v, int string)
{
	tVZFilterHS_setGain(&VZfilterHS[v][string], dbToATableLookup((gain * 50.f) - 25.f));
}

void  __ATTR_ITCMRAM VZbandrejectSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}

void  __ATTR_ITCMRAM  LadderLowpassSetGain(float gain, int v, int string)
{
	filterGain[v][string] = dbToATableLookup((gain * 24.0f) - 12.0f);
}


void __ATTR_ITCMRAM envelope_tick(int string)
{
	for (int v = 0; v < NUM_ENV; v++)
	{
		if (envOn[v])
		{
			sourceValues[ENV_SOURCE_OFFSET + v][string] = tADSRT_tickNoInterp(&envs[v][string]);
		}
	}
}


void __ATTR_ITCMRAM lfo_tick(int string)
{
	for (int i = 0; i < NUM_LFOS; i++)
	{
		if (lfoOn[i])
		{
			float sample = 0.0f;
			lfoShapeTick[i](&sample,i, string);
			sourceValues[LFO_SOURCE_OFFSET + i][string] = sample;
		}
	}
}


void  __ATTR_ITCMRAM  setEnvelopeAttack(float a, int v, int string)
{
	a = a + 0.001f;
	tADSRT_setAttack(&envs[v][string], a);
}

void  __ATTR_ITCMRAM  setEnvelopeDecay(float d, int v, int string)
{
	d = d + 0.001f;
	tADSRT_setDecay(&envs[v][string], d);
}

void  __ATTR_ITCMRAM  setEnvelopeSustain(float s, int v, int string)
{
	tADSRT_setSustain(&envs[v][string], s);
}

void  __ATTR_ITCMRAM  setEnvelopeRelease(float r, int v, int string)
{
	r = r + 0.001f;
	tADSRT_setRelease(&envs[v][string], r);
}

void  __ATTR_ITCMRAM  setEnvelopeLeak(float leak, int v, int string)
{
	tADSRT_setLeakFactor(&envs[v][string], 0.99995f + 0.00005f*(1.f-leak));
}

void  __ATTR_ITCMRAM  setAmp(float amp, int v, int string)
{
	amplitude[string] = amp;
}

void  __ATTR_ITCMRAM  setMaster(float amp,  int v, int string)
{
	finalMaster[string] = amp;
}

void  __ATTR_ITCMRAM  setTranspose(float in, int v, int string)
{
	transpose = in;
}

void  __ATTR_ITCMRAM  setPitchBendRange(float in, int v, int string)
{
	bendRangeMultiplier = 1.0f / (16383.0f / (in * 2.0f));
}

void  __ATTR_ITCMRAM  setFinalLowpass(float in, int v, int string)
{
	tSVF_setFreqFast(&finalLowpass[string], in);
}


void __ATTR_ITCMRAM tickMappings(void)
{
	interruptChecker = 0;
	for (int i = 0; i < numMappings; i++)
	{
		if (mappings[i].destNumber != 255)
		{
			for (int v = 0; v < numStringsThisBoard; v++)
			{
				float unsmoothedValue = 0.0f;
				float smoothedValue = 0.0f;
				for (int j = 0; j < 3; j++)
				{
					if (mappings[i].hookActive[j])
					{
						float sum = *mappings[i].sourceValPtr[j][v] * mappings[i].amount[j] * *mappings[i].scalarSourceValPtr[j][v];
						if (mappings[i].sourceSmoothed[j])
						{
							smoothedValue += sum;
						}
						else
						{
							unsmoothedValue += sum;
						}
					}
				}
				//sources are now summed - let's add the initial value
				smoothedValue += mappings[i].dest->zeroToOneVal[v];

				tExpSmooth_setDest(&mapSmoothers[i][v], smoothedValue);
				smoothedValue = tExpSmooth_tick(&mapSmoothers[i][v]);
				float finalVal = unsmoothedValue + smoothedValue;

				//now scale the value with the correct scaling function
				mappings[i].dest->realVal[v] = mappings[i].dest->scaleFunc(finalVal);
				//mappings[i].dest->realVal[v] = mappings[i].dest->scaleFunc(unsmoothedValue + mappings[i].dest->zeroToOneVal[v]);
				//and pop that value where it belongs by setting the actual parameter
				mappings[i].dest->setParam(mappings[i].dest->realVal[v], mappings[i].dest->objectNumber, v);
			}
		}
	}


}




void __ATTR_ITCMRAM lfoSawSquareTick(float* sample, int v, int string)
{
	*sample = tSawSquareLFO_tick(&lfoSawSquare[v][string]);
}

void __ATTR_ITCMRAM lfoSineTriTick(float* sample, int v, int string)
{
	*sample = tSineTriLFO_tick(&lfoSineTri[v][string]);
}

void __ATTR_ITCMRAM lfoSineTick(float* sample, int v, int string)
{
    *sample = tCycle_tick(&lfoSine[v][string]);
}

void __ATTR_ITCMRAM lfoTriTick(float* sample, int v, int string)
{
    *sample = tTriLFO_tick(&lfoTri[v][string]);
}
void __ATTR_ITCMRAM lfoSawTick(float* sample, int v, int string)
{
    *sample = (tIntPhasor_tick(&lfoSaw[v][string]) * 2.0f) - 1.0f;
}

void __ATTR_ITCMRAM lfoPulseTick(float* sample, int v, int string)
{
    *sample = tSquareLFO_tick(&lfoPulse[v][string]);
}

void __ATTR_ITCMRAM lfoSawSquareSetRate(float r, int v, int string)
{
	tSawSquareLFO_setFreq(&lfoSawSquare[v][string],r);
}

void __ATTR_ITCMRAM lfoSineTriSetRate(float r, int v, int string)
{
	tSineTriLFO_setFreq(&lfoSineTri[v][string],r);
}
void __ATTR_ITCMRAM lfoSineSetRate(float r, int v, int string)
{
	tCycle_setFreq(&lfoSine[v][string], r);
}
void __ATTR_ITCMRAM lfoTriSetRate(float r, int v, int string)
{
	tTriLFO_setFreq(&lfoTri[v][string], r);
}
void __ATTR_ITCMRAM lfoSawSetRate(float r, int v, int string)
{
	tIntPhasor_setFreq(&lfoSaw[v][string], r);
}
void __ATTR_ITCMRAM lfoPulseSetRate(float r, int v, int string)
{
	 tSquareLFO_setFreq(&lfoPulse[v][string], r);
}


void __ATTR_ITCMRAM lfoSawSquareSetPhase(float p, int v, int string)
{
	tSawSquareLFO_setPhase(&lfoSawSquare[v][string],p);
}
void __ATTR_ITCMRAM lfoSineTriSetPhase(float p, int v, int string)
{
	tSineTriLFO_setPhase(&lfoSineTri[v][string], p);
}
void __ATTR_ITCMRAM lfoSineSetPhase(float p, int v, int string)
{
	tCycle_setPhase(&lfoSine[v][string],p);
}
void __ATTR_ITCMRAM lfoTriSetPhase(float p, int v, int string)
{
	tTriLFO_setPhase(&lfoTri[v][string],p);
}
void __ATTR_ITCMRAM lfoSawSetPhase(float p, int v, int string)
{
	tIntPhasor_setPhase(&lfoSaw[v][string], p);
}
void __ATTR_ITCMRAM lfoPulseSetPhase(float p, int v, int string)
{
	tSquareLFO_setPhase(&lfoPulse[v][string], p);
}


void __ATTR_ITCMRAM lfoSawSquareSetShape(float s, int v, int string)
{
	tSawSquareLFO_setShape(&lfoSawSquare[v][string],s);
}
void __ATTR_ITCMRAM lfoSineTriSetShape(float s, int v, int string)
{
	tSineTriLFO_setShape(&lfoSineTri[v][string],s);
}
void __ATTR_ITCMRAM lfoSineSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoTriSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoSawSetShape(float s, int v, int string)
{
	//none
}
void __ATTR_ITCMRAM lfoPulseSetShape(float s, int v, int string)
{
	tSquareLFO_setPulseWidth(&lfoPulse[v][string], s);
}






void __ATTR_ITCMRAM  clipperGainSet(float value, int v, int string)
{
	param1[v][string] = dbToATableLookup(value * 24.0f);
}
void __ATTR_ITCMRAM  wavefolderParam1(float value, int v, int string)
{
	param1[v][string] = dbToATableLookup(value * 12.0f);
}
void __ATTR_ITCMRAM  wavefolderParam3(float value, int v, int string)
{
	//value = (value * 0.99f) + 0.00f; //avoid zero
	invCurFB[v][string] = (1.0f / (1.0f + value));
	param3[v][string] = value;
}

void __ATTR_ITCMRAM  tiltParam1(float value, int v, int string)
{
	tVZFilterLS_setGain(&shelf1[v][string], dbToATableLookup(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilterHS_setGain(&shelf2[v][string], dbToATableLookup((value * 30.0f) - 15.0f));
}

void __ATTR_ITCMRAM  tiltParam2(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilterBell_setFreq(&bell1[v][string], value);
}
void __ATTR_ITCMRAM  tiltParam3(float value, int v, int string)
{
	tVZFilterBell_setBandwidth(&bell1[v][string], (value +1.0f)*6.0f);//TODO: make this match plugin
}
void __ATTR_ITCMRAM  tiltParam4(float value, int v, int string)
{
	tVZFilterBell_setGain(&bell1[v][string], dbToATableLookup((value * 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM  compressorParam1(float value, int v, int string)
{
	comp[v][string]->T = value*-24.0f;
}
void __ATTR_ITCMRAM  compressorParam2(float value, int v, int string)
{
	comp[v][string]->R = ((value*10.0f)+1.0f);
	comp[v][string]->invR  = 1.0f / comp[v][string]->R;
}

void __ATTR_ITCMRAM  compressorParam3(float value, int v, int string)
{
	comp[v][string]->M = value * 18.0f;
}

void __ATTR_ITCMRAM  compressorParam4(float value, int v, int string)
{
	value = (value +  0.001f);
	comp[v][string]->tauAttack = fasterexpf(-1.0f/(value * comp[v][string]->sampleRate));
}

void __ATTR_ITCMRAM  compressorParam5(float value, int v, int string)
{
	value = (value + 0.001f);
	comp[v][string]->tauRelease = fasterexpf(-1.0f/(value * comp[v][string]->sampleRate));
}

void __ATTR_ITCMRAM  offsetParam2(float value, int v, int string)
{
	param2[v][string] = (value * 2.0f) - 1.0f;
}
void __ATTR_ITCMRAM param2Linear(float value, int v, int string)
{
	param2[v][string] = value;
}
void __ATTR_ITCMRAM param3Linear(float value, int v, int string)
{
	param3[v][string] = value;
}
void __ATTR_ITCMRAM param3Soft(float value, int v, int string)
{
	param3[v][string] = (value * .99f) + 0.01f;
	shapeDividerS[v][string] = 1.0f / (param3[v][string] - ((param3[v][string]*param3[v][string]*param3[v][string]) * 0.3333333f));
}

void __ATTR_ITCMRAM param3Hard(float value, int v, int string)
{
	param3[v][string] = ((value * .99f) + 0.01f) * HALF_PI;
	float tempDiv = arm_sin_f32(param3[v][string]);
	if (tempDiv == 0.0f)
	{
		tempDiv = 0.001f;
	}
	shapeDividerH[v][string] = 1.0f/tempDiv;
}

void __ATTR_ITCMRAM param3Poly(float value, int v, int string)
{
	param3[v][string] = ((value * .99f) + 0.01f)* HALF_PI;

    float tempDiv = fastSine(param3[v][string]);
    if (tempDiv == 0.0f)
    {
        tempDiv = 0.001f;
    }
    polyDivider[v][string] = 1.0f/tempDiv;
}

void __ATTR_ITCMRAM param4Linear(float value, int v, int string)
{
	param4[v][string] = value;
}

void __ATTR_ITCMRAM param5Linear(float value, int v, int string)
{
	param5[v][string] = value;
}
void __ATTR_ITCMRAM param2BC(float value, int v, int string)
{
	tCrusher_setQuality (&bc[v][string],value);
}
void __ATTR_ITCMRAM param3BC(float value, int v, int string)
{
	value = (value * inv_oversample) + 0.01f;
	tCrusher_setSamplingRatio (&bc[v][string], value);
}
void __ATTR_ITCMRAM param4BC(float value, int v, int string)
{
	tCrusher_setRound(&bc[v][string], value);
}
void __ATTR_ITCMRAM param5BC(float value, int v, int string)
{
	tCrusher_setOperation(&bc[v][string], value);
}



void __ATTR_ITCMRAM fxMixSet(float value, int v, int string)
{
	fxMix[v][string] = value;
}

void __ATTR_ITCMRAM fxPostGainSet(float value, int v, int string)
{
	fxPostGain[v][string] = dbToATableLookup((value * 24.0f) - 12.0f);
}


//got the idea from https://ccrma.stanford.edu/~jatin/ComplexNonlinearities/Wavefolder.html  -JS
//much more efficient than the lockhart, and can be further optimized with lookups
float __ATTR_ITCMRAM wavefolderTick(float sample, int v, int string)
{
    sample = sample * param1[v][string] + ((param2[v][string] * param1[v][string]));
    float curFB = param3[v][string];
    float curFF = param4[v][string];

    //softclip approx for tanh saturation in original code
    float ffSample = sample;
    if (ffSample <= -1.0f)
    {
    	ffSample = -1.0f;
    } else if (ffSample >= 1.0f)
    {
    	ffSample = 1.0f;
    }
    ffSample = ffSample - ((ffSample * ffSample * ffSample)* 0.3333333f);
    ffSample *= 1.499999f;
    float ff = (curFF * ffSample) + ((1.0f - curFF) * sample);

    //softclip approx for tanh saturation in original code
    float fbSample = wfState[v][string];
    if (fbSample <= -1.0f)
    {
    	fbSample = -1.0f;
    } else if (fbSample >= 1.0f)
    {
    	fbSample = 1.0f;
    }
    fbSample = fbSample - ((fbSample * fbSample * fbSample)* 0.3333333f);
    fbSample *= 1.499999f;
    float fb = curFB * fbSample;

    wfState[v][string] = (ff + fb) - param5[v][string] * arm_sin_f32(TWO_PI * sample); //maybe switch for our own sine lookup (avoid the if statements in the CMSIS code)
    sample = wfState[v][string] * invCurFB[v][string];
    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


void __ATTR_ITCMRAM chorusParam1(float value, int v, int string)
{
	param1[v][string] = value * 5780.0f + 10.0f;
}
void __ATTR_ITCMRAM chorusParam2(float value, int v, int string)
{
	param2[v][string] = value * 0.1f;
}

void __ATTR_ITCMRAM chorusParam3(float value, int v, int string)
{
    tCycle_setFreq(&mod1[v][string], (value * 0.4f) + 0.01f);
}

void __ATTR_ITCMRAM chorusParam4(float value, int v, int string)
{
    tCycle_setFreq(&mod2[v][string], (value * 0.4444444f) + 0.011f);
}


void __ATTR_ITCMRAM delayParam1(float value, int v, int string)
{
    tTapeDelay_setDelay(&tapeDelay[v][string], value * 30000.0f + 1.0f);
}

void __ATTR_ITCMRAM delayParam2(float value, int v, int string)
{
	param2[v][string] = LEAF_clip(0.0f, value * 1.1f, 1.1f);
}

void __ATTR_ITCMRAM delayParam3(float value, int v, int string)
{
    tSVF_setFreqFast(&FXlowpass[v][string], (value * 127.0f));
}

void __ATTR_ITCMRAM delayParam4(float value, int v, int string)
{
    tSVF_setFreqFast(&FXhighpass[v][string], (value * 127.0f));
}

void __ATTR_ITCMRAM delayParam5(float value, int v, int string)
{
	param5[v][string] = (value * 1.5f) + 1.0f;
}

float delayTick(float sample, int v, int string)
{
    sample *= param5[v][string];

    sample = sample + (delayFB[v][string] * param2[v][string]);

    sample = fast_tanh5(sample);

    sample = tFeedbackLeveler_tick(&feedbackControl[v][string], sample);

    delayFB[v][string] = tTapeDelay_tick(&tapeDelay[v][string], sample);
    delayFB[v][string] = tSVF_tick(&FXlowpass[v][string], delayFB[v][string]);
    sample = tSVF_tick(&FXhighpass[v][string], delayFB[v][string]);
    sample = fast_tanh5(sample);
    delayFB[v][string] = sample;
    return sample;
}

float __ATTR_ITCMRAM chorusTick(float sample, int v, int string)
{
	tLinearDelay_setDelay(&delay1[v][string], param1[v][string] * .707f * (1.0f + param2[v][string] * tCycle_tick(&mod1[v][string])));
    tLinearDelay_setDelay(&delay2[v][string], param1[v][string] * .5f * (1.0f - param2[v][string] * tCycle_tick(&mod2[v][string])));
    float temp = tLinearDelay_tick(&delay1[v][string], sample) - sample;
    temp += tLinearDelay_tick(&delay2[v][string], sample) - sample;
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
	//float temp = 0.0f;
    return -temp;
}

float __ATTR_ITCMRAM shaperTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    float temp = LEAF_shaper(sample + (param2[v][string] * param1[v][string]),param3[v][string]);
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    return temp;
}

float __ATTR_ITCMRAM blankTick(float sample, int v, int string)
{
    return sample;
}

float __ATTR_ITCMRAM tiltFilterTick(float sample, int v, int string)
{
    sample = tVZFilterLS_tick(&shelf1[v][string], sample);
    sample = tVZFilterHS_tick(&shelf2[v][string], sample);
    sample = tVZFilterBell_tick(&bell1[v][string], sample);
    return sample;
}

float __ATTR_ITCMRAM tanhTick(float sample, int v, int string)
{
    float gain = param1[v][string];
	sample = sample * gain;
    gain = gain * 0.5f;
    //need to do something with shape param
    float temp = tanhf(sample + (param2[v][string]*gain));
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    //temp *= param4[v][string];
    temp = tanhf(temp);
    //temp = tHighpass_tick(&dcBlock2, temp);
    return temp;
}


float __ATTR_ITCMRAM softClipTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    sample = sample + param2[v][string];
    //float shape = param3[v][string];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = (sample) - (((sample * sample * sample))* 0.3333333f);
        //sample = sample * shapeDividerS[v][string];
    }

    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


float __ATTR_ITCMRAM hardClipTick(float sample, int v, int string)
{

    sample = sample * param1[v][string];
    sample = sample + param2[v][string];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = arm_sin_f32(  (arm_sin_f32(sample*param3[v][string]) * shapeDividerH[v][string]) * param3[v][string]);
        sample = sample * shapeDividerH[v][string];
    }

    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}


float __ATTR_ITCMRAM polynomialShaperTick(float sample, int v, int string)
{

    sample = sample * param1[v][string];
    sample = sample + param2[v][string];

    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }

	sample = fastSine(  (fastSine(sample*param3[v][string]) * polyDivider[v][string]) * param3[v][string]);
	sample = sample * polyDivider[v][string];


    sample = tHighpass_tick(&dcBlock1[v][string], sample);
    return sample;
}
float __ATTR_ITCMRAM satTick(float sample, int v, int string)
{;
    sample = sample * param1[v][string];
    float temp = (sample + (param2[v][string] * param1[v][string])) / (1.0f + fabs(sample + param2[v][string]));
    temp = tHighpass_tick(&dcBlock1[v][string], temp);
    temp = tHighpass_tick(&dcBlock2[v][string], temp);
    temp = LEAF_tanh(temp);
    return temp;
}



float __ATTR_ITCMRAM bcTick(float sample, int v, int string)
{
    sample = sample * param1[v][string];
    return tCrusher_tick(&bc[v][string], sample);
}


float __ATTR_ITCMRAM compressorTick(float sample, int v, int string)
{
    //return tCompressor_tickWithTableHardKnee(&comp[v][string], sample);
	return tCompressor_tick(&comp[v][string], sample);
}

float __ATTR_ITCMRAM  FXlowpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXlowpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXhighpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXhighpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXbandpassTick(float sample, int v, int string)
{
	return tSVF_tick(&FXbandpass[v][string], sample);
}

float __ATTR_ITCMRAM  FXdiodeLowpassTick(float sample, int v, int string)
{
	return tDiodeFilter_tick(&FXdiodeFilters[v][string], sample);
}

float __ATTR_ITCMRAM  FXVZpeakTick(float sample, int v, int string)
{
	return tVZFilterBell_tick(&FXVZfilterPeak[v][string], sample);
}

float __ATTR_ITCMRAM  FXVZlowshelfTick(float sample, int v, int string)
{
	return tVZFilterLS_tick(&FXVZfilterLS[v][string], sample);
}
float __ATTR_ITCMRAM  FXVZhighshelfTick(float sample, int v, int string)
{
	return tVZFilterHS_tick(&FXVZfilterHS[v][string], sample);
}
float __ATTR_ITCMRAM  FXVZbandrejectTick(float sample, int v, int string)
{
	return  tVZFilter_tickEfficient(&FXVZfilterBR[v][string], sample);
}

float __ATTR_ITCMRAM  FXLadderLowpassTick(float sample, int v, int string)
{
	return tLadderFilter_tick(&FXLadderfilter[v][string], sample);
}
//cutoffparams

void  __ATTR_ITCMRAM FXLowpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tSVF_setFreqFast(&FXlowpass[v][string], value);
}
void __ATTR_ITCMRAM FXHighpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tSVF_setFreqFast(&FXhighpass[v][string], value);
}

void __ATTR_ITCMRAM FXBandpassParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
    tSVF_setFreqFast(&FXbandpass[v][string], value);
}

void __ATTR_ITCMRAM FXDiodeParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tDiodeFilter_setFreqFast(&FXdiodeFilters[v][string], value);
}
void __ATTR_ITCMRAM FXPeakParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterBell_setFreq(&FXVZfilterPeak[v][string], value);
}
void __ATTR_ITCMRAM FXLowShelfParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
    tVZFilterLS_setFreqFast(&FXVZfilterLS[v][string], value);
}
void __ATTR_ITCMRAM FXHighShelfParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterHS_setFreqFast(&FXVZfilterHS[v][string], value);
}
void __ATTR_ITCMRAM FXNotchParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilter_setFreqFast(&FXVZfilterBR[v][string], value);
}
void __ATTR_ITCMRAM FXLadderParam1(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tLadderFilter_setFreqFast(&FXLadderfilter[v][string], value);
}

//gain params

void __ATTR_ITCMRAM FXPeakParam2(float value, int v, int string)
{
	 tVZFilterBell_setGain(&FXVZfilterPeak[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXLowShelfParam2(float value, int v, int string)
{
	tVZFilterLS_setGain(&FXVZfilterLS[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXHighShelfParam2(float value, int v, int string)
{
	tVZFilterHS_setGain(&FXVZfilterHS[v][string], dbToATableLookup((value * 50.f) - 25.f));
}

void __ATTR_ITCMRAM FXNotchParam2(float value, int v, int string)
{
	tVZFilter_setGain(&FXVZfilterBR[v][string], dbToATableLookup((value * 50.f) - 25.f));

}
//resonance params
void __ATTR_ITCMRAM FXLowpassParam3(float value, int v, int string)
{
	tSVF_setQ(&FXlowpass[v][string], value);
}

void __ATTR_ITCMRAM FXHighpassParam3(float value, int v, int string)
{
    tSVF_setQ(&FXhighpass[v][string], value);
}

void __ATTR_ITCMRAM FXBandpassParam3(float value, int v, int string)
{
    tSVF_setQ(&FXbandpass[v][string], value);
}

void __ATTR_ITCMRAM FXDiodeParam3(float value, int v, int string)
{
	tDiodeFilter_setQ(&FXdiodeFilters[v][string], value);
}


void __ATTR_ITCMRAM FXPeakParam3(float value, int v, int string)
{
	tVZFilterBell_setBandwidth(&FXVZfilterPeak[v][string], value);
}


void __ATTR_ITCMRAM FXLowShelfParam3(float value, int v, int string)
{
	tVZFilterLS_setResonance(&FXVZfilterLS[v][string], value);
}


void __ATTR_ITCMRAM FXHighShelfParam3(float value, int v, int string)
{
	tVZFilterHS_setResonance(&FXVZfilterHS[v][string], value);
}


void __ATTR_ITCMRAM FXNotchParam3(float value, int v, int string)
{
	tVZFilter_setResonance(&FXVZfilterBR[v][string], value);
}


void __ATTR_ITCMRAM FXLadderParam3(float value, int v, int string)
{
	tLadderFilter_setQ(&FXLadderfilter[v][string], value);
}




/////NOISE///

void __ATTR_ITCMRAM noiseSetTilt(float value, int v, int string)
{
	tVZFilterLS_setGain(&noiseShelf1[string], dbToATableLookup(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilterHS_setGain(&noiseShelf2[string], dbToATableLookup((value * 30.0f) - 15.0f));
}


void __ATTR_ITCMRAM noiseSetGain(float value, int v, int string)
{
	tVZFilterBell_setGain(&noiseBell1[string], dbToATableLookup((value* 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM noiseSetFreq(float value, int v, int string)
{
	value = (value * 77.0f) + 42.0f;
	tVZFilterBell_setFreq(&noiseBell1[string], faster_mtof(value));
	//value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);

}


void __ATTR_ITCMRAM noise_tick(int string)
{
	float enabled = params[Noise].realVal[string];
	float amp = params[NoiseAmp].realVal[string];
	float filterSend = params[NoiseFilterSend].realVal[string];
	amp = amp < 0.f ? 0.f : amp;
	float sample = random_values[randomValPointer++];
	sample = tVZFilterLS_tick(&noiseShelf1[string], sample);
	sample = tVZFilterHS_tick(&noiseShelf2[string], sample);
	sample = tVZFilterBell_tick(&noiseBell1[string], sample);
	sample = sample * amp;
	float normSample = (sample + 1.f) * 0.5f;
	sourceValues[NOISE_SOURCE_OFFSET][string] = normSample;
	noiseOuts[0][string] = sample * filterSend *  enabled;
	noiseOuts[1][string] = sample * (1.f-filterSend) * enabled ;
}




void __ATTR_ITCMRAM HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{
	if ((!diskBusy)&& (presetReady))
	{
		audioFrameFunction(HALF_BUFFER_SIZE);

	}
	else
	{
		for (int i = 0; i < HALF_BUFFER_SIZE; i++)
		{
			audioOutBuffer[HALF_BUFFER_SIZE+i] = 0;
		}
	}
	if (voice != prevVoice)
	{
		if (voice == 63)
		{

			switchStrings = 1;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 62)
		{

			switchStrings = 2;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 61)
		{
			audioFrameFunction = audioFrameAdditive;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else if (voice == 60)
		{
			audioFrameFunction = audioFrameVocal;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else
		{
			audioFrameFunction = audioFrameSynth;
			presetWaitingToLoad = 1;
			presetNumberToLoad = voice;
			presetReady = 0;
			if (prevVoice > 60)
			{
				resetStringInputs = 1;
			}
			frameLoadOverCount = 0;
		}
	}
	prevVoice = voice;
	SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)audioOutBuffer) & ~(uint32_t)0x1F), AUDIO_BUFFER_SIZE+32);
}

void __ATTR_ITCMRAM HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	if ((!diskBusy)&& (presetReady))
	{
		audioFrameFunction(0);

	}
	else
	{
		for (int i = 0; i < HALF_BUFFER_SIZE; i++)
		{
			audioOutBuffer[i] = 0;
		}
	}
	if (voice != prevVoice)
	{
		if (voice == 63)
		{

			switchStrings = 1;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 62)
		{

			switchStrings = 2;
			diskBusy = 0;
			resetStringInputs = 1;
		}
		else if (voice == 61)
		{
			audioFrameFunction = audioFrameAdditive;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else if (voice == 60)
		{
			audioFrameFunction = audioFrameVocal;
			currentActivePreset = voice;
			diskBusy = 0;
			presetReady = 1;
			resetStringInputs = 1;
		}
		else
		{
			audioFrameFunction = audioFrameSynth;
			presetWaitingToLoad = 1;
			presetNumberToLoad = voice;
			presetReady = 0;
			if (prevVoice > 60)
			{
				resetStringInputs = 1;
			}
			frameLoadOverCount = 0;
		}
	}
	prevVoice = voice;
	SCB_CleanDCache_by_Addr((uint32_t*)(((uint32_t)audioOutBuffer) & ~(uint32_t)0x1F), AUDIO_BUFFER_SIZE+32);
}

void __ATTR_ITCMRAM HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
}



