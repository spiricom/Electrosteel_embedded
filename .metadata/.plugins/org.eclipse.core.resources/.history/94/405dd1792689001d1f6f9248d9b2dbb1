/*
 * audiostream.c
 *
 *  Created on: Aug 30, 2019
 *      Author: jeffsnyder
 */


/* Includes ------------------------------------------------------------------*/

#include "main.h"
#include "leaf.h"
#include "codec.h"
#include "i2c.h"
#include "gpio.h"
#include "spi.h"
#include "parameters.h"
#include "audiostream.h"
#include "arm_math.h"
//the audio buffers are put in the D2 RAM area because that is a memory location that the DMA has access to.
int32_t audioOutBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2;
int32_t audioInBuffer[AUDIO_BUFFER_SIZE] __ATTR_RAM_D2;

cStack midiStack;

char small_memory[SMALL_MEM_SIZE];
char medium_memory[MED_MEM_SIZE] __ATTR_RAM_D1;
char large_memory[LARGE_MEM_SIZE] __ATTR_SDRAM;
tMempool mediumPool;
tMempool largePool;

void audioFrame(uint16_t buffer_offset);
uint32_t audioTick(float* samples);

HAL_StatusTypeDef transmit_status;
HAL_StatusTypeDef receive_status;

uint32_t codecReady = 0;

uint32_t frameCounter = 0;

int stringPositions[4];

int newPluck = 0;
int newBar = 0;

uint8_t pluck[26];
uint8_t bar[8];



float decayExpBuffer[DECAY_EXP_BUFFER_SIZE]__ATTR_RAM_D2;
int previousStringInputs[12];

float volumeAmps128[128] = {0.000562, 0.000569, 0.000577, 0.000580, 0.000587, 0.000601, 0.000622, 0.000650, 0.000676, 0.000699, 0.000720, 0.000739, 0.000753, 0.000766, 0.000791, 0.000826, 0.000872, 0.000912, 0.000953, 0.001012, 0.001091, 0.001188, 0.001270, 0.001360, 0.001465, 0.001586, 0.001717, 0.001829, 0.001963, 0.002118, 0.002295, 0.002469, 0.002636, 0.002834, 0.003063, 0.003322, 0.003496, 0.003750, 0.004143, 0.004675, 0.005342, 0.005880, 0.006473, 0.007122, 0.007827, 0.008516, 0.009167, 0.009968, 0.010916, 0.012014, 0.012944, 0.013977, 0.015352, 0.017070, 0.019130, 0.020965, 0.022847, 0.024823, 0.026891, 0.028835, 0.030496, 0.033044, 0.036478, 0.040799, 0.045093, 0.049150, 0.053819, 0.059097, 0.064986, 0.070712, 0.076315, 0.081930, 0.087560, 0.093117, 0.098283, 0.104249, 0.111012, 0.118575, 0.124879, 0.131163, 0.141721, 0.156554, 0.175663, 0.195870, 0.213414, 0.228730, 0.241817, 0.252675, 0.264038, 0.276776, 0.290871, 0.306323, 0.322794, 0.338528, 0.353711, 0.368343, 0.382424, 0.393015, 0.406556, 0.426763, 0.453639, 0.487182, 0.522242, 0.550876, 0.573000, 0.588613, 0.598943, 0.613145, 0.628104, 0.643820, 0.660293, 0.676658, 0.692845, 0.709881, 0.727766, 0.746500, 0.764505, 0.782949, 0.802346, 0.822696, 0.844189, 0.867268, 0.886360, 0.901464, 0.912581, 0.921606, 0.932834, 0.944061};

BOOL bufferCleared = TRUE;

int numBuffersToClearOnLoad = 2;
int numBuffersCleared = 0;

#define NUM_STRINGS 12
#define NUM_STRINGS_PER_BOARD 4
volatile int firstString = 0;
volatile int lastString = 0;
volatile int lastStringPlusOne = 0;

tExpSmooth stringFreqSmoothers[NUM_STRINGS_PER_BOARD];

tExpSmooth volumeSmoother;
tExpSmooth knobSmoothers[4];

tSlide freqSlider[NUM_STRINGS_PER_BOARD];




//function pointers
shapeTick_t shapeTick[NUM_OSC];
filterTick_t filterTick[NUM_FILT];
lfoShapeTick_t lfoShapeTick[NUM_LFOS];
effectTick_t effectTick[NUM_EFFECT];

//oscillators
tMBSaw saw[NUM_OSC];
tMBPulse pulse[NUM_OSC];
tCycle sine[NUM_OSC];
tMBTriangle tri[NUM_OSC];

// Using seperate objects for pairs to easily maintain phase relation
tMBSawPulse sawPaired[NUM_OSC];
tMBSineTri sinePaired[NUM_OSC];

//noise
float noiseOuts[2];
tVZFilter noiseShelf1, noiseShelf2, noiseBell1;
tNoise noise;
tIntPhasor lfoSaw[NUM_LFOS];
tSquareLFO lfoPulse[NUM_LFOS];
tCycle lfoSine[NUM_LFOS];
tTriLFO lfoTri[NUM_LFOS];
tSawSquareLFO lfoSawSquare[NUM_LFOS];
tSineTriLFO lfoSineTri[NUM_LFOS];
uint8_t lfoOn[NUM_LFOS];

//oscillator outputs
float outSamples[2][NUM_OSC];

//source vals
float sourceValues[NUM_SOURCES];

tExpSmooth mapSmoothers[MAX_NUM_MAPPINGS];
tExpSmooth pitchSmoother[NUM_OSC];
tExpSmooth filterCutoffSmoother[NUM_FILT];


float freqMult[NUM_OSC];
float bendRangeMultiplier = 0.002929866324849f; //default to divide by 48


//filters
tDiodeFilter diodeFilters[NUM_FILT];
tVZFilter VZfilterPeak[NUM_FILT];
tVZFilter VZfilterLS[NUM_FILT];
tVZFilter VZfilterHS[NUM_FILT];
tVZFilter VZfilterBR[NUM_FILT];
tSVF lowpass[NUM_FILT];
tSVF highpass[NUM_FILT];
tSVF bandpass[NUM_FILT];
tLadderFilter Ladderfilter[NUM_FILT];

float filterGain[NUM_FILT];

//envelopes
tADSRT envs[NUM_ENV];
float expBuffer[EXP_BUFFER_SIZE];
float expBufferSizeMinusOne;
float decayExpBuffer[DECAY_EXP_BUFFER_SIZE];
float decayExpBufferSizeMinusOne;


//effects
 tHighpass dcBlock1[NUM_EFFECT];
 tHighpass dcBlock2[NUM_EFFECT];
 tVZFilter shelf1[NUM_EFFECT], shelf2[NUM_EFFECT], bell1[NUM_EFFECT];
 tCompressor comp[NUM_EFFECT];
 tCrusher bc[NUM_EFFECT];
 tLockhartWavefolder wf[NUM_EFFECT];
 tLinearDelay delay1[NUM_EFFECT];
 tLinearDelay delay2[NUM_EFFECT];
 tCycle mod1[NUM_EFFECT];
 tCycle mod2[NUM_EFFECT];
 float fxMix[NUM_EFFECT];
 float fxPostGain[NUM_EFFECT];
 tDiodeFilter FXdiodeFilters[NUM_EFFECT];
 tVZFilter FXVZfilterPeak[NUM_EFFECT];
 tVZFilter FXVZfilterLS[NUM_EFFECT];
 tVZFilter FXVZfilterHS[NUM_EFFECT];
 tVZFilter FXVZfilterBR[NUM_EFFECT];
 tSVF FXlowpass[NUM_EFFECT];
 tSVF FXhighpass[NUM_EFFECT];
 tSVF FXbandpass[NUM_EFFECT];
 tLadderFilter FXLadderfilter[NUM_EFFECT];
//master
float amplitude = 0.0f;
float finalMaster = 1.0f;

tSimplePoly myPoly;
float bend;
float transpose = 0.0f;
tNoise noise;

#define OVERSAMPLE 2
float inv_oversample = 1.0f / OVERSAMPLE;

tOversampler os;
float oversamplerArray[OVERSAMPLE];

float upState1[128];
float downState1[128];

tSVF finalLowpass;

uint8_t voiceSounding = 0;

LEAF leaf;

union breakFloat{
	float f;
	uint8_t b[4];
};


float paramsFromBrain[16];
uint maxVolumes[NUM_STRINGS];
float invMaxVolumes[NUM_STRINGS];
uint stringInputs[NUM_STRINGS];

float octave = 1.0f;

float stringMappedPositions[NUM_STRINGS];
float stringFrequencies[NUM_STRINGS];

float volumePedal = 0.0f;
float knobScaled[4];
float stringMIDIPitches[NUM_STRINGS_PER_BOARD];
//TODO:
// frets are measured at 3 7 12 and 19   need to redo these measurements with an accurately set capo
float fretMeasurements[4][4] ={
		{62750.0f, 61600.0f, 31785.0f, 0.0f},
		{39600.0f, 41500.0f, 15700.0f, 0.0f},
		{27520.0f, 30200.0f, 8458.0f, 0.0f},
		{9490.0f, 13600.0f, 2674.0f, 0.0f}
	};

float fretScaling[4] = {1.0f, 0.6666666666666f, 0.5f, 0.25f};

float stringOctave[NUM_STRINGS];
int voice = 0;
int dualSlider = 0;
int neck = 0;

int currentBarBuffer = 0;
int currentPluckBuffer = 0;

int newLevers = 0;
int edit = 0;
int whichTable = 0;
int presetReady = 0;

/**********************************************/

float map(float value, float istart, float istop, float ostart, float ostop)
{
    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
}


void audioInit(I2C_HandleTypeDef* hi2c, SAI_HandleTypeDef* hsaiOut, SAI_HandleTypeDef* hsaiIn)
{
	// Initialize LEAF.

	LEAF_init(&leaf, SAMPLE_RATE, small_memory, SMALL_MEM_SIZE, &randomNumber);

	tMempool_init (&mediumPool, medium_memory, MED_MEM_SIZE, &leaf);
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE, &leaf);

	leaf.clearOnAllocation = 1;
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0

	int bit0 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1);
	int bit1 = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5);

	firstString = (bit0+(bit1 << 1)) * NUM_STRINGS_PER_BOARD;


	for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
	{

		tSlide_init(&freqSlider[i], 1, 20, &leaf);

		tExpSmooth_init(&stringFreqSmoothers[i],1.0f, 0.05f, &leaf);
	}


	tExpSmooth_init(&volumeSmoother,0.0f, 0.0005f, &leaf);
	for (int i = 0; i < 4; i++)
	{
		tExpSmooth_init(&knobSmoothers[i],0.0f, 0.0005f, &leaf);
	}

	for(int i = 0; i < NUM_OSC; i++)
	{
		tMBSaw_init(&saw[i], &leaf);

		tMBPulse_init(&pulse[i], &leaf);

		tCycle_init(&sine[i], &leaf);

		tMBTriangle_init(&tri[i], &leaf);

		tMBSawPulse_init(&sawPaired[i], &leaf);

		tMBSineTri_init(&sinePaired[i], &leaf);

	    tExpSmooth_init(&pitchSmoother[i], 64.0f, 0.01f, &leaf);
	}

	for (int i = 0; i < NUM_FILT; i++)
	{
		tSVF_init(&lowpass[i], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
		tSVF_init(&highpass[i], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
		tSVF_init(&bandpass[i], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
		tDiodeFilter_init(&diodeFilters[i], 2000.f, 0.5f, &leaf);
		tVZFilter_init(&VZfilterPeak[i], Bell, 2000.f, 1.0f, &leaf);
		tVZFilter_init(&VZfilterLS[i], Lowshelf, 2000.f, 1.0f, &leaf);
		tVZFilter_init(&VZfilterHS[i], Highshelf, 2000.f, 1.0f, &leaf);
		tVZFilter_init(&VZfilterBR[i], BandReject, 2000.f, 1.0f, &leaf);
		tLadderFilter_init(&Ladderfilter[i], 2000.f, 1.0f, &leaf);
	    tExpSmooth_init(&filterCutoffSmoother[i], 64.0f, 0.01f, &leaf);
	}

	for (int i = 0; i < NUM_LFOS; i++)
	{
		tIntPhasor_init(&lfoSaw[i], &leaf);
		tSquareLFO_init(&lfoPulse[i], &leaf);
		tCycle_init(&lfoSine[i], &leaf);
		tTriLFO_init(&lfoTri[i], &leaf);

		tSineTriLFO_init(&lfoSineTri[i], &leaf);
		tSawSquareLFO_init(&lfoSawSquare[i], &leaf);
	}
    //noise
	tVZFilter_init(&noiseShelf1, Lowshelf, 80.0f, 6.0f, &leaf);
	tVZFilter_init(&noiseShelf2, Highshelf, 12000.0f, 6.0f, &leaf);
	tVZFilter_init(&noiseBell1, Bell, 1000.0f, 1.9f, &leaf);
    tNoise_init(&noise, WhiteNoise, &leaf);
    // exponential decay buffer falling from 1 to
    LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE);

    expBufferSizeMinusOne = EXP_BUFFER_SIZE - 1;
    decayExpBufferSizeMinusOne = DECAY_EXP_BUFFER_SIZE - 1;

    for (int i = 0; i < NUM_ENV; i++)
    {
        tADSRT_init(&envs[i], 0.1f,10.f,0.5f,1.0f,decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &leaf);
        tADSRT_setLeakFactor(&envs[i], ((1.0f - 0.1f) * 0.00005f) + 0.99995f);
    }


    for (int i = 0; i < NUM_EFFECT; i++)
    {
		tCrusher_init(&bc[i],&leaf);
		tHighpass_init(&dcBlock1[i], 5.0f,&leaf);
		tHighpass_init(&dcBlock2[i], 5.0f,&leaf);
		tVZFilter_init(&shelf1[i], Lowshelf, 80.0f, 32.0f,  &leaf);
		tVZFilter_init(&shelf2[i], Highshelf, 12000.0f, 32.0f, &leaf);
		tVZFilter_init(&bell1[i], Bell, 1000.0f, 1.9f, &leaf);
		tVZFilter_setSampleRate(&shelf1[i], SAMPLE_RATE * OVERSAMPLE);
		tVZFilter_setSampleRate(&shelf2[i], SAMPLE_RATE * OVERSAMPLE);
		tVZFilter_setSampleRate(&bell1[i], SAMPLE_RATE * OVERSAMPLE);
		tCompressor_init(&comp[i], &leaf);
		tLinearDelay_initToPool(&delay1[i], 4000.0f, 4096, &mediumPool);
		tLinearDelay_initToPool(&delay2[i], 4000.0f, 4096, &mediumPool);
		tCycle_init(&mod1[i], &leaf);
		tCycle_init(&mod2[i], &leaf);
		tCycle_setFreq(&mod1[i], 0.2f);
		tCycle_setFreq(&mod2[i], 0.22222222222f);

        //filters
        tSVF_init(&FXlowpass[i], SVFTypeLowpass, 2000.f, 0.7f, &leaf);
        tSVF_init(&FXhighpass[i], SVFTypeHighpass, 2000.f, 0.7f, &leaf);
        tSVF_init(&FXbandpass[i], SVFTypeBandpass, 2000.f, 0.7f, &leaf);
        tDiodeFilter_init(&FXdiodeFilters[i], 2000.f, 1.0f, &leaf);
        tVZFilter_init(&FXVZfilterPeak[i], Bell, 2000.f, 1.0f, &leaf);
        tVZFilter_init(&FXVZfilterLS[i], Lowshelf, 2000.f, 1.0f, &leaf);
        tVZFilter_init(&FXVZfilterHS[i], Highshelf, 2000.f, 1.0f, &leaf);
        tVZFilter_init(&FXVZfilterBR[i], BandReject, 2000.f, 1.0f, &leaf);
        tLadderFilter_init(&FXLadderfilter[i], 2000.f, 1.0f, &leaf);
    }

    for (int i = 0; i < MAX_NUM_MAPPINGS; i++)
    {
    	tExpSmooth_init(&mapSmoothers[i], 0.0f, 0.01f, &leaf);
    }



	tSimplePoly_init(&myPoly, 1, &leaf);
	tNoise_init(&noise, WhiteNoise, &leaf);

	tOversampler_init(&os, OVERSAMPLE, 0, &leaf);

	tSVF_init(&finalLowpass, SVFTypeLowpass, 19000.f, 0.3f, &leaf);


    //int idx = (int)(log2f(OVERSAMPLE))-1;
    //int numTaps = __leaf_tablesize_firNumTaps[idx];
/*
	arm_fir_decimate_init_f32(
	        &osD,
			numTaps,
			OVERSAMPLE,
			(float*) &__leaf_table_fir2XLow,
			(float*) &downState1,
	        OVERSAMPLE);

	arm_fir_interpolate_init_f32(
	        &osI,
			OVERSAMPLE,
			numTaps,
			(float*) &__leaf_table_fir2XLow,
			(float*) &upState1,
	        1);
*/

	for (int i = 0; i < AUDIO_BUFFER_SIZE; i++)
	{
		audioOutBuffer[i] = 0;
	}

	// set up the I2S driver to send audio data to the codec (and retrieve input as well)
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);

	// with the CS4271 codec IC, the SAI Transmit and Receive must be happening before the chip will respond to
	// I2C setup messages (it seems to use the masterclock input as it's own internal clock for i2c data, etc)
	// so while we used to set up codec before starting SAI, now we need to set up codec afterwards, and set a flag to make sure it's ready

	//now to send all the necessary messages to the codec
	AudioCodec_init(hi2c);
	HAL_Delay(1);

}

volatile uint16_t volumePedalInt;
float octaveRatios[4] = {0.5f, 1.0f, 2.0f, 4.0f};
int octaveIndex = 1;
int stringOctaveIndex[4];
const int syncMap[3] = {2, 0, 1};
uint32_t timeMIDI = 0;
uint32_t timeFrame = 0;
float frameLoadPercentage = 0.0f;
float frameLoadMultiplier = 1.0f / (10000.0f * AUDIO_FRAME_SIZE);
void audioFrame(uint16_t buffer_offset)
{

	volatile uint32_t tmpCnt = 0;
	uint32_t tempCountFrame = DWT->CYCCNT;
	//take care of MIDI messages that came in
	tmpCnt = DWT->CYCCNT;
	while(midiStack.readCnt != midiStack.writeCnt)
	{
		uint8_t firstByte = midiStack.buffer[midiStack.readCnt][0];
		int8_t readCount = midiStack.readCnt;
		if (firstByte == 0x90)
		{
			sendNoteOn(midiStack.buffer[readCount][1], midiStack.buffer[readCount][2]);
		}
		else if (firstByte == 0xb0)
		{
			sendCtrl(midiStack.buffer[readCount][1], midiStack.buffer[readCount][2]);
		}
		else if (firstByte == 0xe0)
		{
			sendPitchBend(midiStack.buffer[readCount][1], midiStack.buffer[readCount][2]);
		}
		midiStack.readCnt = (midiStack.readCnt + 1) & 63;
	}
	timeMIDI = DWT->CYCCNT - tmpCnt;

	int32_t current_sample = 0;


	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	if (newBar)
	{

		int currentBarBufferL = currentBarBuffer;

		if ((SPI_RX[6 + (8 * currentBarBufferL)] == 254) && (SPI_RX[7 + (8 * currentBarBufferL)] == 253))
		{
			for (int j = 0; j < 2; j++)
			{
				stringPositions[j] =  ((uint16_t)SPI_RX[(j * 2) + (8 * currentBarBufferL)] << 8) + ((uint16_t)SPI_RX[(j * 2) + (8 * currentBarBufferL) + 1] & 0xff);
				if ((stringPositions[j] == 65535) || (stringPositions[j] > fretMeasurements[0][j]))
				{
					stringMappedPositions[j] = 1.0f;
				}
				else if ((stringPositions[j] >= fretMeasurements[1][j]) && (stringPositions[j] <= fretMeasurements[0][j]))
				{
					stringMappedPositions[j] = map((float)stringPositions[j], fretMeasurements[0][j], fretMeasurements[1][j], fretScaling[0], fretScaling[1]);
				}
				else if ((stringPositions[j] >= fretMeasurements[2][j]) && (stringPositions[j] < fretMeasurements[1][j]))
				{
					stringMappedPositions[j] = map((float)stringPositions[j], fretMeasurements[1][j], fretMeasurements[2][j], fretScaling[1], fretScaling[2]);
				}
				else
				{
					stringMappedPositions[j] = map((float)stringPositions[j], fretMeasurements[2][j], fretMeasurements[3][j], fretScaling[2], fretScaling[3]);
				}
			}
			float myMappedPos = 0.0f;
			for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
			{

				if (dualSlider)
				{
					if ((stringMappedPositions[0] == 1.0f) && (stringMappedPositions[1] < 1.0f))
					{
						stringMappedPositions[0] = stringMappedPositions[1];
					}
					else if ((stringMappedPositions[1] == 1.0f) && (stringMappedPositions[0] < 1.0f))
					{
						stringMappedPositions[1] = stringMappedPositions[0];
					}
					myMappedPos = LEAF_interpolation_linear(stringMappedPositions[0], stringMappedPositions[1], ((float)(i+firstString)) * 0.090909090909091f);
				}
				else
				{
					myMappedPos =  stringMappedPositions[0];
				}
				float tempFreq = (1.0f / myMappedPos) * mtof(stringMIDIPitches[i]);
				tempFreq = tSlide_tick(&freqSlider[i], tempFreq);
				tExpSmooth_setDest(&stringFreqSmoothers[i], tempFreq);
			}


		}
		newBar = 0;

	}

	if (newLevers)
	{
		int currentLeverBufferL = currentLeverBuffer;

		if ((SPI_LEVERS[72 + (currentLeverBufferL * 74)] == 254) && (SPI_LEVERS[73 + (currentLeverBufferL * 74)] == 253))
		{


			for (int i = 0; i < 16; i++)
			{
				paramsFromBrain[i] = SPI_LEVERS[(i + 56) + (currentLeverBuffer * 74)] * 0.003921568627451f; //scaled 0.0 to 1.0

			}

			union breakFloat tempBreak;

			for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
			{


				tempBreak.b[0] = SPI_LEVERS[((i+firstString) * 4) + (currentLeverBufferL * 74)];
				tempBreak.b[1] = SPI_LEVERS[((i+firstString) * 4) + 1 + (currentLeverBufferL * 74)];
				tempBreak.b[2] = SPI_LEVERS[((i+firstString) * 4) + 2 + (currentLeverBufferL * 74)];
				tempBreak.b[3] = SPI_LEVERS[((i+firstString) * 4) + 3 + (currentLeverBufferL * 74)];
				stringMIDIPitches[i] = tempBreak.f;

#if 0
				if (voice == 0)
				{
					tLivingString2_setPickupPos(&strings[i], .9999f);
				}

				if ((voice == 0) || (voice == 1))
				{
					tADSRT_setDecay(&fenvelopes[i], params[7] * 1000.0f);//noise env
					tADSRT_setDecay(&envelopes[i][0], params[0] * 50000.0f);//other env
					tADSRT_setDecay(&envelopes[i][1], params[2] * 50000.0f);//filter env
					tCycle_setFreq(&LFOs[i][0], (params[5 ] * 2.0f) + LFOdetunes[i][0]);
				}
#endif
			}

			for (int i = 0; i < 4; i++)
			{
				tExpSmooth_setDest(&knobSmoothers[i], (SPI_LEVERS[(i + 49) + (currentLeverBufferL * 74)] * 0.0078125)); //   divided by 128
			}

			int modeBit = SPI_LEVERS[48 + (currentLeverBufferL * 74)];

			neck = (modeBit >> 6) & 1;
			dualSlider = (modeBit >> 5) & 1;

			edit = (modeBit >> 4) & 1;
			voice = SPI_LEVERS[55 + (currentLeverBufferL * 74)];

			octave = (((int32_t) (modeBit & 15) - 1 ) * 12.0f);
			octaveIndex = (modeBit & 15);
			//octave = powf(2.0f,((int32_t) (modeBit & 3) - 1 ));

			volumePedalInt = ((uint16_t)SPI_LEVERS[53 + (currentLeverBufferL * 74)] << 8) + ((uint16_t)SPI_LEVERS[54 + (currentLeverBufferL * 74)] & 0xff);
			volumePedal = volumePedalInt * 0.0002442002442f;
			tExpSmooth_setDest(&volumeSmoother,volumePedal);
		}
	}

	if ((codecReady)&&(presetReady))
	{

		//mono operation, no need to compute right channel. Also for loop iterating by 2 instead of 1 to avoid if statement.
		for (int i = 0; i < HALF_BUFFER_SIZE; i+=2)
		{
			current_sample = (int32_t)(audioTickL() * TWO_TO_23);
			audioOutBuffer[buffer_offset + i] = current_sample;
			audioOutBuffer[buffer_offset + i + 1] = current_sample;
			//audioOutBuffer[buffer_offset + i + 1] = current_sample;
		}


	}
	timeFrame = DWT->CYCCNT - tempCountFrame;

	frameLoadPercentage = (float)timeFrame * frameLoadMultiplier;

}



uint32_t audioTick(float* samples)
{

	samples[0]= 0.0f;

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 4; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}

	for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
	{
		stringFrequencies[i] = tExpSmooth_tick(&stringFreqSmoothers[i]);
	}

	if (newPluck)
	{
		for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{

				float amplitz = stringInputs[i] * 0.00005f;
				amplitz = LEAF_clip(0.0, amplitz, 1.0f);
				//float amplitz = stringInputs[i] * 0.000015259021897f;
				//tExpSmooth_setVal(&smoother[i], amplitz);
				//tExpSmooth_setDest(&smoother[i], 0.0f);
				stringOctaveIndex[i] = octaveIndex;
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);
			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET);
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}


	float volIdx = LEAF_clip(47.0f, ((volumeSmoothed * 80.0f) + 47.0f), 127.0f);
	int volIdxInt = (int) volIdx;
	float alpha = volIdx-volIdxInt;
	int volIdxIntPlus = (volIdxInt + 1) & 127;
	float omAlpha = 1.0f - alpha;
	float out = volumeAmps128[volIdxInt] * omAlpha;
	out += volumeAmps128[volIdxIntPlus] * alpha;



	for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
	{
		float tempSamp = 0.0f;

		//tCycle_setFreq(&sines[i], stringFrequencies[i] * octaveRatios[stringOctaveIndex[i]]);
		//tempSamp = tCycle_tick(&sines[i]);


		samples[0] += tempSamp;
	}

	//samples[0] *= out; //put back in!!!!!!!!!!!!!!!!!

	samples[0] = (samples[0] * 0.25f);
	samples[1] = samples[0];
	return 0;
}




float oscOuts[2][NUM_OSC];
float oscAmpMult = 1.0f;
float oscAmpMultArray[4] = {0.0f, 1.0f, 0.5f, 0.333333f};
uint32_t timeOsc = 0;

void __ATTR_ITCMRAM oscillator_tick(float note)
{
    //if (loadingTables || !enabled) return;
	interruptChecker = 0;
	uint32_t tempCount1 = DWT->CYCCNT;


	for (int osc = 0; osc < NUM_OSC; osc++)
	{
		param* oscParams = &params[OSC_PARAMS_OFFSET + osc * OscParamsNum];

		float fine = oscParams[OscFine].realVal;
		float freqOffset= oscParams[OscFreq].realVal;
		float shape = oscParams[OscShape].realVal;
		float amp = oscParams[OscAmp].realVal;
		float filterSend = oscParams[OscFilterSend].realVal;
		int sync = oscParams[OscisSync].realVal > 0.5f; // probably faster than previous roundf version but haven't tested
		float freqToSmooth = (note + (fine*0.01f));
		tExpSmooth_setDest(&pitchSmoother[osc], freqToSmooth);
		freqToSmooth = mtof(tExpSmooth_tick(&pitchSmoother[osc]));
		float finalFreq = (freqToSmooth * freqMult[osc]) + freqOffset ;

		float sample = 0.0f;

		shapeTick[osc](&sample, osc, finalFreq, shape, sync);

		sample *= amp;

		//sourceValues[OSC_SOURCE_OFFSET + osc] = sample; // the define of zero may be wasteful
		sourceValues[osc] = sample;

		sample *= oscAmpMult; // divide down gain if more than one oscillator is sounding (computed at preset load)

		oscOuts[0][osc] = sample * (filterSend) * oscParams[OscEnabled].realVal;
		oscOuts[1][osc] = sample * (1.0f - filterSend) * oscParams[OscEnabled].realVal;
	}
	timeOsc = DWT->CYCCNT - tempCount1;
}


void __ATTR_ITCMRAM  sawSquareTick(float* sample, int v, float freq, float shape, int sync)
{
    tMBSawPulse_setFreq(&sawPaired[v], freq);
    tMBSawPulse_setShape(&sawPaired[v], shape);
    if (sync)
    {
    	tMBSawPulse_sync(&sawPaired[v], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]]);

    }
    *sample += tMBSawPulse_tick(&sawPaired[v]) * 2.f;
}

void __ATTR_ITCMRAM  sineTriTick(float* sample, int v, float freq, float shape, int sync)
{
    tMBSineTri_setFreq(&sinePaired[v], freq);
    tMBSineTri_setShape(&sinePaired[v],shape);
    if (sync)
    {
    	tMBSineTri_sync(&sinePaired[v], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]]);
    }
    *sample += tMBSineTri_tick(&sinePaired[v]) * 2.0f;
}

void __ATTR_ITCMRAM  sawTick(float* sample, int v, float freq, float shape, int sync)
{
    tMBSaw_setFreq(&saw[v], freq);
    if (sync)
	{
		tMBSaw_sync(&saw[v], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]]);
	}
    *sample += tMBSaw_tick(&saw[v]) * 2.f;;
}

void __ATTR_ITCMRAM  pulseTick(float* sample, int v, float freq, float shape, int sync)
{
    tMBPulse_setFreq(&pulse[v], freq);
    tMBPulse_setWidth(&pulse[v], shape);
    if (sync)
	{
		tMBPulse_sync(&pulse[v], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]]);
	}
    *sample += tMBPulse_tick(&pulse[v]) * 2.f;;
}

void __ATTR_ITCMRAM  sineTick(float* sample, int v, float freq, float shape, int sync)
{
    tCycle_setFreq(&sine[v], freq);
    *sample += tCycle_tick(&sine[v]);
}

void __ATTR_ITCMRAM  triTick(float* sample, int v, float freq, float shape, int sync)
{
    tMBTriangle_setFreq(&tri[v], freq);
    tMBTriangle_setWidth(&tri[v], shape);
    if (sync)
	{
		tMBTriangle_sync(&tri[v], sourceValues[syncMap[OSC_SOURCE_OFFSET + v]]);
	}
    *sample += tMBTriangle_tick(&tri[v]) * 2.0f;;
}

void __ATTR_ITCMRAM  userTick(float* sample, int v, float freq, float shape, int sync)
{
    //tWaveOscS_setFreq(&wave[v], freq);
    //tWaveOscS_setIndex(&wave[v], shape);
    //*sample += tWaveOscS_tick(&wave[v]);
}

uint32_t timeFilt = 0;

float __ATTR_ITCMRAM filter_tick(float* samples, float note)
{
	interruptChecker = 0;
	uint32_t tempCount1 = DWT->CYCCNT;
	float cutoff[2];
	uint8_t enabledFilt[2] = {0,0};
	for (int f = 0; f < NUM_FILT; f++)
	{
		param* filtParams = &params[FILTER_PARAMS_OFFSET + f * FilterParamsNum];
		float enabled = filtParams[FilterEnabled].realVal;
		enabledFilt[f] = (enabled > 0.5f);
		if (!enabledFilt[f]) continue;

		float MIDIcutoff = filtParams[FilterCutoff].realVal;
		float keyFollow = filtParams[FilterKeyFollow].realVal;
		if (isnan(note))
		{
			note = 0.0f; //is this necessary?
		}

		cutoff[f] = MIDIcutoff + (note * keyFollow);
		cutoff[f] = LEAF_clip(0.0f, (cutoff[f]-16.0f) * 35.929824561403509f, 4095.0f);
		//smoothing may not be necessary
		tExpSmooth_setDest(&filterCutoffSmoother[f], cutoff[f]);
		cutoff[f] = tExpSmooth_tick(&filterCutoffSmoother[f]);
	}

	float  sp = params[FilterSeriesParallelMix].realVal;

	if (enabledFilt[0])
	{
		filterTick[0](&samples[0], 0, cutoff[0]);
	}
	float sendToFilter2 = samples[0] * (1.0f - sp);
	samples[1] += sendToFilter2;
	//compute what gets sent to the second filter
	if (enabledFilt[1])
	{
		filterTick[1](&samples[1], 1, cutoff[1]);
	}

	timeFilt = DWT->CYCCNT - tempCount1;
	return samples[1] + (samples[0] * sp);
}


void __ATTR_ITCMRAM  lowpassTick(float* sample, int v, float cutoff)
{
	tSVF_setFreqFast(&lowpass[v], cutoff);
	*sample = tSVF_tick(&lowpass[v], *sample);
    *sample *= filterGain[v];
}

void __ATTR_ITCMRAM  highpassTick(float* sample, int v, float cutoff)
{
	tSVF_setFreqFast(&highpass[v], cutoff);
	*sample = tSVF_tick(&highpass[v], *sample);
    *sample *= filterGain[v];
}

void __ATTR_ITCMRAM  bandpassTick(float* sample, int v, float cutoff)
{
	tSVF_setFreqFast(&bandpass[v], cutoff);
	*sample = tSVF_tick(&bandpass[v], *sample);
    *sample *= filterGain[v];
}

void __ATTR_ITCMRAM  diodeLowpassTick(float* sample, int v, float cutoff)
{
	tDiodeFilter_setFreqFast(&diodeFilters[v], cutoff);
	*sample = tDiodeFilter_tick(&diodeFilters[v], *sample);
    *sample *= filterGain[v];
}

void __ATTR_ITCMRAM  VZpeakTick(float* sample, int v, float cutoff)
{
	tVZFilter_setFreqFast(&VZfilterPeak[v], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterPeak[v], *sample);
}

void __ATTR_ITCMRAM  VZlowshelfTick(float* sample, int v, float cutoff)
{
	tVZFilter_setFreqFast(&VZfilterLS[v], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterLS[v], *sample);
}
void __ATTR_ITCMRAM  VZhighshelfTick(float* sample, int v, float cutoff)
{
	tVZFilter_setFreqFast(&VZfilterHS[v], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterHS[v], *sample);
}
void __ATTR_ITCMRAM  VZbandrejectTick(float* sample, int v, float cutoff)
{
	tVZFilter_setFreqFast(&VZfilterBR[v], cutoff);
	*sample = tVZFilter_tickEfficient(&VZfilterBR[v], *sample);
    *sample *= filterGain[v];
}

void __ATTR_ITCMRAM  LadderLowpassTick(float* sample, int v, float cutoff)
{
	tLadderFilter_setFreqFast(&Ladderfilter[v], cutoff);
	*sample = tLadderFilter_tick(&Ladderfilter[v], *sample);
    *sample *= filterGain[v];
}




void __ATTR_ITCMRAM setFreqMultPitch(float pitch, int osc)
{
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal > 0.5f) ///check for value of 1 since this is a float
	{
		pitch = roundf(pitch);
	}
	else
	{
		freqMult[osc] = powf(1.059463094359295f, pitch);
	}
}

void __ATTR_ITCMRAM setFreqMultHarm(float harm, int osc)
{
	if (params[OSC_PARAMS_OFFSET + osc * OscParamsNum + OscisStepped].realVal > 0.5f) ///check for value of 1 since this is a float
	{
		harm = roundf(harm);
	}

	if (harm >= 0)
	{
		freqMult[osc] = (harm + 1);
	}
	else
	{
		freqMult[osc] = (1.0f / fabsf((harm - 1)));
	}

}




void __ATTR_ITCMRAM  lowpassSetQ(float q, int v)
{
    tSVF_setQ(&lowpass[v], q);
}

void __ATTR_ITCMRAM  highpassSetQ(float q, int v)
{
    tSVF_setQ(&highpass[v], q);
}

void __ATTR_ITCMRAM  bandpassSetQ(float q, int v)
{
    tSVF_setQ(&bandpass[v], q);
}

void __ATTR_ITCMRAM  diodeLowpassSetQ(float q, int v)
{
	tDiodeFilter_setQ(&diodeFilters[v], q);
}

void __ATTR_ITCMRAM  VZpeakSetQ(float q, int v)
{
	tVZFilter_setResonance(&VZfilterPeak[v], q);
}

void __ATTR_ITCMRAM  VZlowshelfSetQ(float q, int v)
{
	tVZFilter_setResonance(&VZfilterLS[v], q);
}

void __ATTR_ITCMRAM  VZhighshelfSetQ(float q, int v)
{
	tVZFilter_setResonance(&VZfilterHS[v], q);
}

void __ATTR_ITCMRAM  VZbandrejectSetQ(float q, int v)
{
	tVZFilter_setResonance(&VZfilterBR[v], q);
}

void __ATTR_ITCMRAM  LadderLowpassSetQ(float q, int v)
{
	tLadderFilter_setQ(&Ladderfilter[v], q);
}

void __ATTR_ITCMRAM  lowpassSetGain(float gain, int v)
{
    filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  highpassSetGain(float gain, int v)
{
	filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  bandpassSetGain(float gain, int v)
{
	filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  diodeLowpassSetGain(float gain, int v)
{
	filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

void __ATTR_ITCMRAM  VZpeakSetGain(float gain, int v)
{
	 tVZFilter_setGain(&VZfilterPeak[v], fasterdbtoa((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZlowshelfSetGain(float gain, int v)
{
	tVZFilter_setGain(&VZfilterLS[v], fasterdbtoa((gain * 50.f) - 25.f));
}

void __ATTR_ITCMRAM  VZhighshelfSetGain(float gain, int v)
{
	tVZFilter_setGain(&VZfilterLS[v], fasterdbtoa((gain * 50.f) - 25.f));
}

void  __ATTR_ITCMRAM VZbandrejectSetGain(float gain, int v)
{
	filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

void  __ATTR_ITCMRAM  LadderLowpassSetGain(float gain, int v)
{
	filterGain[v] = fasterdbtoa((gain * 24.0f) - 12.0f);
}

uint32_t timeEnv = 0;
void __ATTR_ITCMRAM envelope_tick(void)
{
	interruptChecker = 0;
	uint32_t tempCount1 = DWT->CYCCNT;
	for (int v = 0; v < NUM_ENV; v++)
	{
		float value = tADSRT_tick(&envs[v]); //used to be noInterp but wanted to check if this sounds better and isn't too slow
		sourceValues[ENV_SOURCE_OFFSET + v] = value;
	}
	timeEnv = DWT->CYCCNT - tempCount1;
}

uint32_t timeLFO = 0;
void __ATTR_ITCMRAM lfo_tick(void)
{
	interruptChecker = 0;
	uint32_t tempCount1 = DWT->CYCCNT;
	for (int i = 0; i < NUM_LFOS; i++)
	{
		float sample = 0.0f;
		if (lfoOn[i])
		{
			lfoShapeTick[i](&sample,i);
		}
		sourceValues[LFO_SOURCE_OFFSET + i] = sample;
	}
	timeLFO = DWT->CYCCNT - tempCount1;
}


void  __ATTR_ITCMRAM  setEnvelopeAttack(float a, int v)
{
	tADSRT_setAttack(&envs[v], a);
}

void  __ATTR_ITCMRAM  setEnvelopeDecay(float d, int v)
{
	tADSRT_setDecay(&envs[v], d);
}

void  __ATTR_ITCMRAM  setEnvelopeSustain(float s, int v)
{
	tADSRT_setSustain(&envs[v], s);
}

void  __ATTR_ITCMRAM  setEnvelopeRelease(float r, int v)
{
	tADSRT_setRelease(&envs[v], r);
}

void  __ATTR_ITCMRAM  setEnvelopeLeak(float leak, int v)
{
	tADSRT_setLeakFactor(&envs[v], 0.99995f + 0.00005f*(1.f-leak));
}

void  __ATTR_ITCMRAM  setAmp(float amp, int v)
{
	amplitude = amp;
}

void  __ATTR_ITCMRAM  setMaster(float amp, int v)
{
	finalMaster = amp;
}

void  __ATTR_ITCMRAM  setTranspose(float in, int v)
{
	transpose = in;
}

void  __ATTR_ITCMRAM  setPitchBendRange(float in, int v)
{
	bendRangeMultiplier = 1.0f / (16383.0f / (in * 2.0f));
}

void  __ATTR_ITCMRAM  setFinalLowpass(float in, int v)
{
	tSVF_setFreqFast(&finalLowpass, LEAF_clip(0.0f, (in-16.0f) * 35.929824561403509f, 4095.0f));
}

uint32_t timeMap = 0;
void __ATTR_ITCMRAM tickMappings(void)
{
	interruptChecker = 0;
	uint32_t tempCount1 = DWT->CYCCNT;
	for (int i = 0; i < numMappings; i++)
	{
		float unsmoothedValue = 0.0f;
		float smoothedValue = 0.0f;
		for (int j = 0; j < mappings[i].numHooks; j++)
		{
			float sum = *mappings[i].sourceValPtr[j] * mappings[i].amount[j] * *mappings[i].scalarSourceValPtr[j];
			if (mappings[i].sourceSmoothed[j])
			{
				smoothedValue += sum;
			}
			else
			{
				unsmoothedValue += sum;
			}
		}
		//sources are now summed - let's add the initial value
		smoothedValue += mappings[i].dest->zeroToOneVal;

		tExpSmooth_setDest(&mapSmoothers[i], smoothedValue);
		smoothedValue = tExpSmooth_tick(&mapSmoothers[i]);
		float finalVal = unsmoothedValue + smoothedValue;

		//now scale the value with the correct scaling function
		mappings[i].dest->realVal = mappings[i].dest->scaleFunc(finalVal);

		//and pop that value where it belongs by setting the actual parameter
		mappings[i].dest->setParam(mappings[i].dest->realVal, mappings[i].dest->objectNumber);
	}
	timeMap = DWT->CYCCNT - tempCount1;

}
uint32_t timeTick = 0;
uint32_t oversampleCount = 0;

float  audioTickL(void)
{
	uint32_t tempCount5 = DWT->CYCCNT;
	float sample = 0.0f;
	uint8_t fxPre = (params[FXPREPOST_PARAMS_OFFSET].realVal > 0.5f);
	//run mapping ticks
	tickMappings();



#if 0
	float note = bend + transpose + (float)tSimplePoly_getPitch(&myPoly, 0);

	int tempNoteIntPart = (int)note;
	float tempNoteFloatPart = note - (float)tempNoteIntPart;
				//int tempPitchClassIntPart =tempNoteIntPart % 12;
	float dev1 = 0.0f;
	float dev2 = 0.0f;
	//float dev1 = (fractionalMidi[tempNoteIntPart] * (1.0f - tempNoteFloatPart));
	//float dev2 =  (fractionalMidi [(tempNoteIntPart+1)] * tempNoteFloatPart);
	note = ( dev1  + dev2);
#endif


	samples[0]= 0.0f;

	float volumeSmoothed = tExpSmooth_tick(&volumeSmoother);

	for (int i = 0; i < 4; i++)
	{
		knobScaled[i] = tExpSmooth_tick(&knobSmoothers[i]);
	}

	for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
	{
		stringFrequencies[i] = tExpSmooth_tick(&stringFreqSmoothers[i]);
	}

	if (newPluck)
	{
		for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
		{
			if ((previousStringInputs[i] == 0) && (stringInputs[i] > 0))
			{

				float amplitz = stringInputs[i] * 0.00005f;
				amplitz = LEAF_clip(0.0, amplitz, 1.0f);
				//float amplitz = stringInputs[i] * 0.000015259021897f;
				//tExpSmooth_setVal(&smoother[i], amplitz);
				//tExpSmooth_setDest(&smoother[i], 0.0f);
				stringOctaveIndex[i] = octaveIndex;
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_SET);
			}
			else if ((previousStringInputs[i] > 0) && (stringInputs[i] == 0))
			{
				//note off
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, GPIO_PIN_RESET);
			}
			previousStringInputs[i] = stringInputs[i];
		}
		newPluck = 0;
	}

	float note = stringFrequencies[0];

	envelope_tick();
	lfo_tick();
	oscillator_tick(note);
	noise_tick();
	float filterSamps[2] = {0.0f, 0.0f};
	for (int i = 0; i < NUM_OSC; i++)
	{
		filterSamps[0] += oscOuts[0][i];
		filterSamps[1] += oscOuts[1][i];
	}
	filterSamps[0] += noiseOuts[0];
	filterSamps[1] += noiseOuts[1];
	//sample = filterSamps[0];
	sample = filter_tick(&filterSamps[0], note);
	if (fxPre)
	{
		sample *= amplitude;
	}
	uint32_t tempCount1 = DWT->CYCCNT;

	//oversample for non-linear effects (distortion, etc)
	tOversampler_upsample(&os, sample, oversamplerArray);

	//arm_fir_interpolate_f32(&osI, &sample, (float*)&oversamplerArray, 1);


	for (int i = 0; i < NUM_EFFECT; i++) {

		for (int j = 0; j < OVERSAMPLE; j++)
		{
			float dry = oversamplerArray[j]; //store the dry value to mix later
			oversamplerArray[j] = effectTick[i](oversamplerArray[j], i); //run the effect
			oversamplerArray[j] = ((1.0f - fxMix[i]) * dry) + (fxMix[i] * oversamplerArray[j]); //mix in dry/wet at the "mix" amount
			oversamplerArray[j] *= fxPostGain[i]; //apply postgain
		}
	}

	//hard clip before downsampling to get a little more antialiasing from clipped signal.
	for (int i = 0; i < (OVERSAMPLE); i++)
	{
		oversamplerArray[i] = LEAF_clip(-1.0f, oversamplerArray[i], 1.0f);
	}
	//downsample to get back to normal sample rate
	sample = tOversampler_downsample(&os, oversamplerArray);

	//arm_fir_decimate_f32(&osD, (float*)&oversamplerArray, &sample, OVERSAMPLE);

	uint32_t tempCount2 = DWT->CYCCNT;

	oversampleCount = tempCount2-tempCount1;

	if (!fxPre)
	{
		sample *= amplitude;
	}


	sample = tSVF_tick(&finalLowpass, sample);
	sample *= finalMaster;
	sample = LEAF_clip(-1.0f, sample, 1.0f);

	uint32_t tempCount6 = DWT->CYCCNT;
	timeTick = tempCount6-tempCount5;
	return sample * audioMasterLevel * 0.95f;
}



void __ATTR_ITCMRAM sendNoteOn(uint8_t note, uint8_t velocity)
{
	if (velocity > 0)
	{
		tSimplePoly_noteOn(&myPoly, note, velocity);
		float fvelocity = (float)velocity;
		fvelocity = ((0.007685533519034f*fvelocity) + 0.0239372430f);
		fvelocity = fvelocity * fvelocity;
		for (int v = 0; v < NUM_ENV; v++)
		{
			param* envParams = &params[ENVELOPE_PARAMS_OFFSET + v * EnvelopeParamsNum];
			float useVelocity = envParams[EnvelopeVelocity].realVal;
			float envVel = fvelocity;
			if (useVelocity == 0) envVel = 1.f;
		    tADSRT_on(&envs[v], envVel);
		    voiceSounding = 1;
		}
		for (int v = 0; v < NUM_LFOS; v++)
		{
			param* lfoParams = &params[LFO_PARAMS_OFFSET + v * LFOParamsNum];
			float noteOnSync = lfoParams[LFOSync].realVal;
			if (noteOnSync > 0.5f)
			{
				lfoParams[LFOPhase].setParam(lfoParams[LFOPhase].realVal, v);
			}
		}
	}
	else
	{
		tSimplePoly_noteOff(&myPoly, note);
		for (int v = 0; v < NUM_ENV; v++)
		{
			tADSRT_off(&envs[v]);
		}
	}
	//store random number as source
	//store velocity as source
	// store scaled pitch as source
}


void __ATTR_ITCMRAM sendCtrl(uint8_t ctrl, uint8_t value)
{
	//HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_7);

	sourceValues[CTRL_SOURCE_OFFSET + (ctrl - CTRL_MIDI_START)] = (float)value * INV_TWO_TO_7;
}


void __ATTR_ITCMRAM sendPitchBend(uint8_t value, uint8_t ctrl)
{
	int bendInt = value + (ctrl << 7);
	bendInt = bendInt - 8192;
	bend = bendInt * bendRangeMultiplier; //by default, divide by (16383 / 96 semitones)

}







void __ATTR_ITCMRAM HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	if (!diskBusy)
	audioFrame(HALF_BUFFER_SIZE);
}

void __ATTR_ITCMRAM HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	if (!diskBusy)
	audioFrame(0);
}





void lfoSawSquareTick(float* sample, int v)
{
	*sample = tSawSquareLFO_tick(&lfoSawSquare[v]);
}

void lfoSineTriTick(float* sample, int v)
{
	*sample = tSineTriLFO_tick(&lfoSineTri[v]);
}

void lfoSineTick(float* sample, int v)
{
    *sample = tCycle_tick(&lfoSine[v]);
}

void lfoTriTick(float* sample, int v)
{
    *sample = tTriLFO_tick(&lfoTri[v]);
}
void lfoSawTick(float* sample, int v)
{
    *sample = (tIntPhasor_tick(&lfoSaw[v]) * 2.0f) - 1.0f;
}

void lfoPulseTick(float* sample, int v)
{
    *sample = tSquareLFO_tick(&lfoPulse[v]);
}

void lfoSawSquareSetRate(float r, int v)
{
	tSawSquareLFO_setFreq(&lfoSawSquare[v],r);
}

void lfoSineTriSetRate(float r, int v)
{
	tSineTriLFO_setFreq(&lfoSineTri[v],r);
}
void lfoSineSetRate(float r, int v)
{
	tCycle_setFreq(&lfoSine[v], r);
}
void lfoTriSetRate(float r, int v)
{
	tTriLFO_setFreq(&lfoTri[v], r);
}
void lfoSawSetRate(float r, int v)
{
	tIntPhasor_setFreq(&lfoSaw[v], r);
}
void lfoPulseSetRate(float r, int v)
{
	 tSquareLFO_setFreq(&lfoPulse[v], r);
}


void lfoSawSquareSetPhase(float p, int v)
{
	tSawSquareLFO_setPhase(&lfoSawSquare[v],p);
}
void lfoSineTriSetPhase(float p, int v)
{
	tSineTriLFO_setPhase(&lfoSineTri[v], p);
}
void lfoSineSetPhase(float p, int v)
{
	tCycle_setPhase(&lfoSine[v],p);
}
void lfoTriSetPhase(float p, int v)
{
	tTriLFO_setPhase(&lfoTri[v],p);
}
void lfoSawSetPhase(float p, int v)
{
	tIntPhasor_setPhase(&lfoSaw[v], p);
}
void lfoPulseSetPhase(float p, int v)
{
	tSquareLFO_setPhase(&lfoPulse[v], p);
}


void lfoSawSquareSetShape(float s, int v)
{
	tSawSquareLFO_setShape(&lfoSawSquare[v],s);
}
void lfoSineTriSetShape(float s, int v)
{
	tSineTriLFO_setShape(&lfoSineTri[v],s);
}
void lfoSineSetShape(float s, int v)
{
	//none
}
void lfoTriSetShape(float s, int v)
{
	//none
}
void lfoSawSetShape(float s, int v)
{
	//none
}
void lfoPulseSetShape(float s, int v)
{
	tSquareLFO_setPulseWidth(&lfoPulse[v], s);
}



void __ATTR_ITCMRAM cStack_init(cStack* stack)
{
    stack->writeCnt = 0;
    stack->readCnt = 0;
    for (int i = 0; i < 64; i++)
    {
        stack->buffer[i][0] = -1;
        stack->buffer[i][1] = -1;
        stack->buffer[i][2] = -1;
    }
}
void __ATTR_ITCMRAM cStack_push(cStack* stack, uint8_t val, uint8_t val1, uint8_t val2)
{
    stack->buffer[stack->writeCnt][0] = val;
    stack->buffer[stack->writeCnt][1] = val1;
    stack->buffer[stack->writeCnt][2] = val2;
    stack->writeCnt = (stack->writeCnt + 1 ) & 63;
}

void __ATTR_ITCMRAM cStack_pop(cStack* stack, uint8_t* output)
{
    output[0] = stack->buffer[stack->readCnt][0];
    output[1] = stack->buffer[stack->readCnt][1];
    output[2] = stack->buffer[stack->readCnt][2];
    stack->readCnt = (stack->readCnt + 1) & 63;
}

float param1[NUM_EFFECT];
float param2[NUM_EFFECT];
float param3[NUM_EFFECT];
float param4[NUM_EFFECT];
float param5[NUM_EFFECT];
float shapeDividerS[NUM_EFFECT];
float shapeDividerH[NUM_EFFECT];
float wfState[NUM_EFFECT] = {0.0f, 0.0f, 0.0f, 0.0f};
float invCurFB[NUM_EFFECT];

void __ATTR_ITCMRAM  clipperGainSet(float value, int v)
{
	param1[v] = fasterdbtoa(value * 24.0f);
}
void __ATTR_ITCMRAM  wavefolderParam1(float value, int v)
{
	param1[v] = fasterdbtoa(value * 12.0f);
}
void __ATTR_ITCMRAM  wavefolderParam3(float value, int v)
{
	//value = (value * 0.99f) + 0.00f; //avoid zero
	invCurFB[v] = (1.0f / (1.0f + value));
	param3[v] = value;
}

void __ATTR_ITCMRAM  tiltParam1(float value, int v)
{
	tVZFilter_setGain(&shelf1[v], fasterdbtoa(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilter_setGain(&shelf2[v], fasterdbtoa((value * 30.0f) - 15.0f));
}

void __ATTR_ITCMRAM  tiltParam2(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilter_setFreqFast(&bell1[v], value);
}
void __ATTR_ITCMRAM  tiltParam3(float value, int v)
{
	tVZFilter_setResonance(&bell1[v], (value +1.0f)*6.0f);//TODO: make this match plugin
}
void __ATTR_ITCMRAM  tiltParam4(float value, int v)
{
	tVZFilter_setGain(&bell1[v], fastdbtoa((value * 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM  compressorParam1(float value, int v)
{
	comp[v]->T = value*-24.0f;
}
void __ATTR_ITCMRAM  compressorParam2(float value, int v)
{
	comp[v]->R = ((value*10.0f)+1.0f);
	comp[v]->invR  = 1.0f / comp[v]->R;
}

void __ATTR_ITCMRAM  compressorParam3(float value, int v)
{
	comp[v]->M = value * 18.0f;
}

void __ATTR_ITCMRAM  compressorParam4(float value, int v)
{
	value = (value +  0.001f);
	comp[v]->tauAttack = fasterexpf(-1.0f/(value * comp[v]->sampleRate));
}

void __ATTR_ITCMRAM  compressorParam5(float value, int v)
{
	value = (value + 0.001f);
	comp[v]->tauRelease = fasterexpf(-1.0f/(value * comp[v]->sampleRate));
}

void __ATTR_ITCMRAM  offsetParam2(float value, int v)
{
	param2[v] = (value * 2.0f) - 1.0f;
}
void __ATTR_ITCMRAM param2Linear(float value, int v)
{
	param2[v] = value;
}
void __ATTR_ITCMRAM param3Linear(float value, int v)
{
	param3[v] = value;
}
void __ATTR_ITCMRAM param3Soft(float value, int v)
{
	param3[v] = (value * .99f) + 0.01f;
	shapeDividerS[v] = 1.0f / (param3[v] - ((param3[v]*param3[v]*param3[v]) * 0.3333333f));
}

void __ATTR_ITCMRAM param3Hard(float value, int v)
{
	param3[v] = ((value * .99f) + 0.01f) * HALF_PI;
	shapeDividerH[v] = 1.0f / arm_sin_f32(param3[v]);
}
void __ATTR_ITCMRAM param4Linear(float value, int v)
{
	param4[v] = value;
}

void __ATTR_ITCMRAM param5Linear(float value, int v)
{
	param5[v] = value;
}
void __ATTR_ITCMRAM param2BC(float value, int v)
{
	tCrusher_setQuality (&bc[v],value);
}
void __ATTR_ITCMRAM param3BC(float value, int v)
{
	value = (value * inv_oversample) + 0.01f;
	tCrusher_setSamplingRatio (&bc[v], value);
}
void __ATTR_ITCMRAM param4BC(float value, int v)
{
	tCrusher_setRound(&bc[v], value);
}
void __ATTR_ITCMRAM param5BC(float value, int v)
{
	tCrusher_setOperation(&bc[v], value);
}



void __ATTR_ITCMRAM fxMixSet(float value, int v)
{
	fxMix[v] = value;
}

void __ATTR_ITCMRAM fxPostGainSet(float value, int v)
{
	fxPostGain[v] = fasterdbtoa((value * 24.0f) - 12.0f);
}


//got the idea from https://ccrma.stanford.edu/~jatin/ComplexNonlinearities/Wavefolder.html  -JS
//much more efficient than the lockhart, and can be further optimized with lookups
float __ATTR_ITCMRAM wavefolderTick(float sample, int v)
{
    sample = sample * param1[v] + ((param2[v] * param1[v]));
    float curFB = param3[v];
    float curFF = param4[v];

    //softclip approx for tanh saturation in original code
    float ffSample = sample;
    if (ffSample <= -1.0f)
    {
    	ffSample = -1.0f;
    } else if (ffSample >= 1.0f)
    {
    	ffSample = 1.0f;
    }
    ffSample = ffSample - ((ffSample * ffSample * ffSample)* 0.3333333f);
    ffSample *= 1.499999f;
    float ff = (curFF * ffSample) + ((1.0f - curFF) * sample);

    //softclip approx for tanh saturation in original code
    float fbSample = wfState[v];
    if (fbSample <= -1.0f)
    {
    	fbSample = -1.0f;
    } else if (fbSample >= 1.0f)
    {
    	fbSample = 1.0f;
    }
    fbSample = fbSample - ((fbSample * fbSample * fbSample)* 0.3333333f);
    fbSample *= 1.499999f;
    float fb = curFB * fbSample;

    wfState[v] = (ff + fb) - param5[v] * arm_sin_f32(TWO_PI * sample); //maybe switch for our own sine lookup (avoid the if statements in the CMSIS code)
    sample = wfState[v] * invCurFB[v];
    sample = tHighpass_tick(&dcBlock1[v], sample);
    return sample;
}

void __ATTR_ITCMRAM chorusParam1(float value, int v)
{
	param1[v] = value * 5780.0f + 10.0f;
}
void __ATTR_ITCMRAM chorusParam2(float value, int v)
{
	param2[v] = value * 0.1f;
}

void __ATTR_ITCMRAM chorusParam3(float value, int v)
{
    tCycle_setFreq(&mod1[v], (value * 0.4f) + 0.01f);
}

void __ATTR_ITCMRAM chorusParam4(float value, int v)
{
    tCycle_setFreq(&mod2[v], (value * 0.4444444f) + 0.011f);
}


float __ATTR_ITCMRAM chorusTick(float sample, int v)
{
	tLinearDelay_setDelay(&delay1[v], param1[v] * .707f * (1.0f + param2[v] * tCycle_tick(&mod1[v])));
    tLinearDelay_setDelay(&delay2[v], param1[v] * .5f * (1.0f - param2[v] * tCycle_tick(&mod2[v])));
    float temp = tLinearDelay_tick(&delay1[v], sample) - sample;
    temp += tLinearDelay_tick(&delay2[v], sample) - sample;
    //temp = tHighpass_tick(&dcBlock1[v], temp);
    return -temp;
}

float __ATTR_ITCMRAM shaperTick(float sample, int v)
{
    sample = sample * param1[v];
    float temp = LEAF_shaper(sample + (param2[v] * param1[v]),param3[v]);
    temp = tHighpass_tick(&dcBlock1[v], temp);
    return temp;
}

float __ATTR_ITCMRAM blankTick(float sample, int v)
{
    return sample;
}

float __ATTR_ITCMRAM tiltFilterTick(float sample, int v)
{
    sample = tVZFilter_tickEfficient(&shelf1[v], sample);
    sample = tVZFilter_tickEfficient(&shelf2[v], sample);
    sample = tVZFilter_tickEfficient(&bell1[v], sample);
    return sample;
}

float __ATTR_ITCMRAM tanhTick(float sample, int v)
{
    float gain = param1[v];
	sample = sample * gain;
    gain = gain * 0.5f;
    //need to do something with shape param
    float temp = tanhf(sample + (param2[v]*gain));
    temp = tHighpass_tick(&dcBlock1[v], temp);
    temp *= param4[v];
    temp = tanhf(temp);
    //temp = tHighpass_tick(&dcBlock2, temp);
    return temp;
}


float __ATTR_ITCMRAM softClipTick(float sample, int v)
{
    sample = sample * param1[v];
    sample = sample + param2[v];
    float shape = param3[v];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = (shape * sample) - ((shape * (sample * sample * sample))* 0.3333333f);
        sample = sample * shapeDividerS[v];
    }

    sample = tHighpass_tick(&dcBlock1[v], sample);
    return sample;
}


float __ATTR_ITCMRAM hardClipTick(float sample, int v)
{

    sample = sample * param1[v];
    sample = sample + param2[v];
    if (sample <= -1.0f)
    {
        sample = -1.0f;
    } else if (sample >= 1.0f)
    {
        sample = 1.0f;
    }
    {
        sample = arm_sin_f32(  (arm_sin_f32(sample*param3[v]) * shapeDividerH[v]) * param3[v]);
        sample = sample * shapeDividerH[v];
    }

    sample = tHighpass_tick(&dcBlock1[v], sample);
    return sample;
}


float __ATTR_ITCMRAM satTick(float sample, int v)
{;
    sample = sample * param1[v];
    float temp = (sample + (param2[v] * param1[v])) / (1.0f + fabs(sample + param2[v]));
    temp = tHighpass_tick(&dcBlock1[v], temp);
    temp = tHighpass_tick(&dcBlock2[v], temp);
    temp = tanhf(temp);
    return temp;
}



float __ATTR_ITCMRAM bcTick(float sample, int v)
{
    sample = sample * param1[v];
    return tCrusher_tick(&bc[v], sample);
}


float __ATTR_ITCMRAM compressorTick(float sample, int v)
{
    return tCompressor_tick(&comp[v], sample);
}

float __ATTR_ITCMRAM  FXlowpassTick(float sample, int v)
{
	return tSVF_tick(&FXlowpass[v], sample);
}

float __ATTR_ITCMRAM  FXhighpassTick(float sample, int v)
{
	return tSVF_tick(&FXhighpass[v], sample);
}

float __ATTR_ITCMRAM  FXbandpassTick(float sample, int v)
{
	return tSVF_tick(&FXbandpass[v], sample);
}

float __ATTR_ITCMRAM  FXdiodeLowpassTick(float sample, int v)
{
	return tDiodeFilter_tick(&FXdiodeFilters[v], sample);
}

float __ATTR_ITCMRAM  FXVZpeakTick(float sample, int v)
{
	return tVZFilter_tickEfficient(&FXVZfilterPeak[v], sample);
}

float __ATTR_ITCMRAM  FXVZlowshelfTick(float sample, int v)
{
	return tVZFilter_tickEfficient(&FXVZfilterLS[v], sample);
}
float __ATTR_ITCMRAM  FXVZhighshelfTick(float sample, int v)
{
	return tVZFilter_tickEfficient(&FXVZfilterHS[v], sample);
}
float __ATTR_ITCMRAM  FXVZbandrejectTick(float sample, int v)
{
	return  tVZFilter_tickEfficient(&FXVZfilterBR[v], sample);
}

float __ATTR_ITCMRAM  FXLadderLowpassTick(float sample, int v)
{
	return tLadderFilter_tick(&FXLadderfilter[v], sample);
}
//cutoffparams

void FXLowpassParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tSVF_setFreqFast(&FXlowpass[v], value);
}
void FXHighpassParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tSVF_setFreqFast(&FXhighpass[v], value);
}

void FXBandpassParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
    tSVF_setFreqFast(&FXbandpass[v], value);
}

void FXDiodeParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tDiodeFilter_setFreqFast(&FXdiodeFilters[v], value);
}
void FXPeakParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilter_setFreqFast(&FXVZfilterPeak[v], value);
}
void FXLowShelfParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
    value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
    tVZFilter_setFreqFast(&FXVZfilterLS[v], value);
}
void FXHighShelfParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilter_setFreqFast(&FXVZfilterHS[v], value);
}
void FXNotchParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilter_setFreqFast(&FXVZfilterBR[v], value);
}
void FXLadderParam1(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tLadderFilter_setFreqFast(&FXLadderfilter[v], value);
}

//gain params

void FXPeakParam2(float value, int v)
{
	 tVZFilter_setGain(&FXVZfilterPeak[v], fasterdbtoa((value * 50.f) - 25.f));
}

void FXLowShelfParam2(float value, int v)
{
tVZFilter_setGain(&FXVZfilterLS[v], fasterdbtoa((value * 50.f) - 25.f));
}

void FXHighShelfParam2(float value, int v)
{
	tVZFilter_setGain(&FXVZfilterHS[v], fasterdbtoa((value * 50.f) - 25.f));
}

void FXNotchParam2(float value, int v)
{
	tVZFilter_setGain(&FXVZfilterBR[v], fasterdbtoa((value * 50.f) - 25.f));

}
//resonance params
void FXLowpassParam3(float value, int v)
{
	tSVF_setQ(&FXlowpass[v], value);
}

void FXHighpassParam3(float value, int v)
{
    tSVF_setQ(&FXhighpass[v], value);
}

void FXBandpassParam3(float value, int v)
{
    tSVF_setQ(&FXbandpass[v], value);
}

void FXDiodeParam3(float value, int v)
{
	tDiodeFilter_setQ(&FXdiodeFilters[v], value);
}


void FXPeakParam3(float value, int v)
{
	tVZFilter_setResonance(&FXVZfilterPeak[v], value);
}


void FXLowShelfParam3(float value, int v)
{
	tVZFilter_setResonance(&FXVZfilterLS[v], value);
}


void FXHighShelfParam3(float value, int v)
{
	tVZFilter_setResonance(&FXVZfilterHS[v], value);
}


void FXNotchParam3(float value, int v)
{
	tVZFilter_setResonance(&FXVZfilterBR[v], value);
}


void FXLadderParam3(float value, int v)
{
	tLadderFilter_setQ(&FXLadderfilter[v], value);
}




/////NOISE///

void __ATTR_ITCMRAM noiseSetTilt(float value, int v)
{
	tVZFilter_setGain(&noiseShelf1, fastdbtoa(-1.0f * ((value * 30.0f) - 15.0f)));
	tVZFilter_setGain(&noiseShelf2, fastdbtoa((value * 30.0f) - 15.0f));
}


void __ATTR_ITCMRAM noiseSetGain(float value, int v)
{
	tVZFilter_setGain(&noiseBell1, fastdbtoa((value* 34.0f) - 17.0f));
}

void __ATTR_ITCMRAM noiseSetFreq(float value, int v)
{
	value = (value * 77.0f) + 42.0f;
	value = LEAF_clip(0.0f, (value-16.0f) * 35.929824561403509f, 4095.0f);
	tVZFilter_setFreqFast(&noiseBell1, value);
}

uint32_t timeNoise = 0;
uint32_t timeRandom = 0;

uint8_t randomValPointer = 0;
void __ATTR_ITCMRAM noise_tick()
{

	float enabled = params[Noise].realVal;
	float amp = params[NoiseAmp].realVal;
	float filterSend = params[NoiseFilterSend].realVal;
	amp = amp < 0.f ? 0.f : amp;

	uint32_t tempCount7 = DWT->CYCCNT;
	float sample = tNoise_tick(&noise);
	uint32_t tempCount8 = DWT->CYCCNT;
	timeNoise = tempCount8-tempCount7;

	uint32_t tempCount9 = DWT->CYCCNT;
	float sample1 = random_values[randomValPointer++];
	uint32_t tempCount10 = DWT->CYCCNT;
	timeRandom = tempCount10-tempCount9;

	sample1 = tVZFilter_tickEfficient(&noiseShelf1, sample1);
	sample = tVZFilter_tickEfficient(&noiseShelf2, sample);
	sample = tVZFilter_tickEfficient(&noiseBell1, sample);
	sample = sample * amp;
	float normSample = (sample + 1.f) * 0.5f;
	sourceValues[3] = normSample;
	noiseOuts[0] = sample * filterSend *  enabled;
	noiseOuts[1] = sample * (1.f-filterSend) * enabled ;


}




void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
	if (hspi == &hspi5)
	{
		currentPluckBuffer = 1;

		if ((SPI_PLUCK_RX[0 + (26*currentPluckBuffer)] == 254) && (SPI_PLUCK_RX[25 + (26*currentPluckBuffer)] == 253))
		{

			for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
			{

				stringInputs[i] = (SPI_PLUCK_RX[((i+firstString)*2)+ 1 + (26*currentPluckBuffer)] << 8) + SPI_PLUCK_RX[((i+firstString)*2)+ 2 + (26*currentPluckBuffer)];
			}
		}
		newPluck = 1;
		HAL_SPI_Receive_DMA(&hspi5, SPI_PLUCK_RX, 52);
	}
	if (hspi == &hspi2)
	{
		/*
		for (int i = 0; i < 8; i++)
		{
			bar[i] = SPI_RX[i+8];
		}
		*/
		newBar = 1;
		currentBarBuffer = 1;
	}

	if (hspi == &hspi1)
	{

		/*
		for (int i = 0; i < 74; i++)
		{
			levers[1][i] = SPI_LEVERS[i];
		}
		*/
		newLevers = 1;
		currentLeverBuffer = 1;
	}
}

void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
	if (hspi == &hspi5)
	{

		currentPluckBuffer = 0;
		if ((SPI_PLUCK_RX[0 + (26*currentPluckBuffer)] == 254) && (SPI_PLUCK_RX[25 + (26*currentPluckBuffer)] == 253))
		{

			for (int i = 0; i < NUM_STRINGS_PER_BOARD; i++)
			{

				stringInputs[i] = (SPI_PLUCK_RX[((i+firstString)*2)+ 1 + (26*currentPluckBuffer)] << 8) + SPI_PLUCK_RX[((i+firstString)*2)+ 2 + (26*currentPluckBuffer)];
			}
		}
		newPluck = 1;

	}
	if (hspi == &hspi2)
	{
		/*
		for (int i = 0; i < 8; i++)
		{
			bar[i] = SPI_RX[i];
		}
		*/
		newBar = 1;
		currentBarBuffer = 0;
	}
	if (hspi == &hspi1)
	{
		/*
		for (int i = 0; i < 74; i++)
		{
			levers[0][i] = SPI_LEVERS[i];
		}
		*/
		newLevers = 1;
		currentLeverBuffer = 0;
	}
}


void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
}

void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{

}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}


